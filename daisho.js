(function (global) {
  var process = {
    title: 'browser',
    browser: true,
    env: {},
    argv: [],
    nextTick: function (fn) {
      setTimeout(fn, 0)
    },
    cwd: function () {
      return '/'
    },
    chdir: function () {
    }
  };
  // Require module
  function require(file, cb) {
    // Handle async require
    if (typeof cb == 'function') {
      return require.load(file, cb)
    }
    // Return module from cache
    if ({}.hasOwnProperty.call(require.cache, file))
      return require.cache[file];
    var resolved = require.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var mod = {
      id: file,
      require: require,
      filename: file,
      exports: {},
      loaded: false,
      parent: null,
      children: []
    };
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    require.cache[file] = mod.exports;
    resolved.call(mod.exports, mod, mod.exports, dirname, file, process);
    mod.loaded = true;
    return require.cache[file] = mod.exports
  }
  require.modules = {};
  require.cache = {};
  require.resolve = function (file) {
    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0
  };
  // define normal static module
  require.define = function (file, fn) {
    require.modules[file] = fn
  };
  require.waiting = {};
  // Determine base path for all modules
  var scripts = document.getElementsByTagName('script');
  var file = scripts[scripts.length - 1].src;
  require.basePath = file.slice(0, file.lastIndexOf('/') + 1);
  // Generate URL for module
  require.urlFor = function (file) {
    var url = file.replace(/^\.?\//, '');
    if (!/\.js$/.test(url))
      url = url + '.js';
    return require.basePath + url
  };
  // Load module async module
  require.load = function (file, cb) {
    // Immediately return previously loaded modules
    if (require.modules[file] != null)
      return cb(require(file));
    // Build URL to request module at
    var url = require.urlFor(file);
    var script = document.createElement('script'), scripts = document.getElementsByTagName('script')[0], callbacks = require.waiting[file] = require.waiting[file] || [];
    // We'll be called when async module is defined.
    callbacks.push(cb);
    // Load module
    script.type = 'text/javascript';
    script.async = true;
    script.src = url;
    script.file = file;
    scripts.parentNode.insertBefore(script, scripts)
  };
  // Define async module
  require.async = function (file, fn) {
    require.modules[file] = fn;
    var cb;
    while (cb = require.waiting[file].shift())
      cb(require(file))
  };
  global.require = require;
  // source: node_modules/broken/lib/index.js
  require.define('broken/lib', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.10.0
    var Promise, PromiseInspection;
    Promise = require('zousan/zousan-min');
    Promise.suppressUncaughtRejectionError = false;
    PromiseInspection = function () {
      function PromiseInspection(arg) {
        this.state = arg.state, this.value = arg.value, this.reason = arg.reason
      }
      PromiseInspection.prototype.isFulfilled = function () {
        return this.state === 'fulfilled'
      };
      PromiseInspection.prototype.isRejected = function () {
        return this.state === 'rejected'
      };
      return PromiseInspection
    }();
    Promise.reflect = function (promise) {
      return new Promise(function (resolve, reject) {
        return promise.then(function (value) {
          return resolve(new PromiseInspection({
            state: 'fulfilled',
            value: value
          }))
        })['catch'](function (err) {
          return resolve(new PromiseInspection({
            state: 'rejected',
            reason: err
          }))
        })
      })
    };
    Promise.settle = function (promises) {
      return Promise.all(promises.map(Promise.reflect))
    };
    Promise.prototype.callback = function (cb) {
      if (typeof cb === 'function') {
        this.then(function (value) {
          return cb(null, value)
        });
        this['catch'](function (error) {
          return cb(error, null)
        })
      }
      return this
    };
    module.exports = Promise  //# sourceMappingURL=index.js.map
  });
  // source: node_modules/zousan/zousan-min.js
  require.define('zousan/zousan-min', function (module, exports, __dirname, __filename, process) {
    !function (t) {
      'use strict';
      function e(t) {
        if (t) {
          var e = this;
          t(function (t) {
            e.resolve(t)
          }, function (t) {
            e.reject(t)
          })
        }
      }
      function n(t, e) {
        if ('function' == typeof t.y)
          try {
            var n = t.y.call(i, e);
            t.p.resolve(n)
          } catch (o) {
            t.p.reject(o)
          }
        else
          t.p.resolve(e)
      }
      function o(t, e) {
        if ('function' == typeof t.n)
          try {
            var n = t.n.call(i, e);
            t.p.resolve(n)
          } catch (o) {
            t.p.reject(o)
          }
        else
          t.p.reject(e)
      }
      var r, i, c = 'fulfilled', u = 'rejected', s = 'undefined', f = function () {
          function t() {
            for (; e.length - n;)
              e[n](), e[n++] = i, n == o && (e.splice(0, o), n = 0)
          }
          var e = [], n = 0, o = 1024, r = function () {
              if (typeof MutationObserver !== s) {
                var e = document.createElement('div'), n = new MutationObserver(t);
                return n.observe(e, { attributes: !0 }), function () {
                  e.setAttribute('a', 0)
                }
              }
              return typeof setImmediate !== s ? function () {
                setImmediate(t)
              } : function () {
                setTimeout(t, 0)
              }
            }();
          return function (t) {
            e.push(t), e.length - n == 1 && r()
          }
        }();
      e.prototype = {
        resolve: function (t) {
          if (this.state === r) {
            if (t === this)
              return this.reject(new TypeError('Attempt to resolve promise with self'));
            var e = this;
            if (t && ('function' == typeof t || 'object' == typeof t))
              try {
                var o = !0, i = t.then;
                if ('function' == typeof i)
                  return void i.call(t, function (t) {
                    o && (o = !1, e.resolve(t))
                  }, function (t) {
                    o && (o = !1, e.reject(t))
                  })
              } catch (u) {
                return void (o && this.reject(u))
              }
            this.state = c, this.v = t, e.c && f(function () {
              for (var o = 0, r = e.c.length; r > o; o++)
                n(e.c[o], t)
            })
          }
        },
        reject: function (t) {
          if (this.state === r) {
            this.state = u, this.v = t;
            var n = this.c;
            n ? f(function () {
              for (var e = 0, r = n.length; r > e; e++)
                o(n[e], t)
            }) : e.suppressUncaughtRejectionError || console.log('You upset Zousan. Please catch rejections: ', t, t.stack)
          }
        },
        then: function (t, i) {
          var u = new e, s = {
              y: t,
              n: i,
              p: u
            };
          if (this.state === r)
            this.c ? this.c.push(s) : this.c = [s];
          else {
            var l = this.state, a = this.v;
            f(function () {
              l === c ? n(s, a) : o(s, a)
            })
          }
          return u
        },
        'catch': function (t) {
          return this.then(null, t)
        },
        'finally': function (t) {
          return this.then(t, t)
        },
        timeout: function (t, n) {
          n = n || 'Timeout';
          var o = this;
          return new e(function (e, r) {
            setTimeout(function () {
              r(Error(n))
            }, t), o.then(function (t) {
              e(t)
            }, function (t) {
              r(t)
            })
          })
        }
      }, e.resolve = function (t) {
        var n = new e;
        return n.resolve(t), n
      }, e.reject = function (t) {
        var n = new e;
        return n.reject(t), n
      }, e.all = function (t) {
        function n(n, c) {
          'function' != typeof n.then && (n = e.resolve(n)), n.then(function (e) {
            o[c] = e, r++, r == t.length && i.resolve(o)
          }, function (t) {
            i.reject(t)
          })
        }
        for (var o = [], r = 0, i = new e, c = 0; c < t.length; c++)
          n(t[c], c);
        return t.length || i.resolve(o), i
      }, typeof module != s && module.exports && (module.exports = e), t.Zousan = e, e.soon = f
    }('undefined' != typeof global ? global : this)
  });
  // source: node_modules/xhr-promise-es6/lib/index.js
  require.define('xhr-promise-es6/lib', function (module, exports, __dirname, __filename, process) {
    /*
 * Copyright 2015 Scott Brady
 * MIT License
 * https://github.com/scottbrady/xhr-promise/blob/master/LICENSE
 */
    var ParseHeaders, XMLHttpRequestPromise, objectAssign;
    ParseHeaders = require('parse-headers/parse-headers');
    objectAssign = require('object-assign');
    /*
 * Module to wrap an XMLHttpRequest in a promise.
 */
    module.exports = XMLHttpRequestPromise = function () {
      function XMLHttpRequestPromise() {
      }
      XMLHttpRequestPromise.DEFAULT_CONTENT_TYPE = 'application/x-www-form-urlencoded; charset=UTF-8';
      XMLHttpRequestPromise.Promise = global.Promise;
      /*
   * XMLHttpRequestPromise.send(options) -> Promise
   * - options (Object): URL, method, data, etc.
   *
   * Create the XHR object and wire up event handlers to use a promise.
   */
      XMLHttpRequestPromise.prototype.send = function (options) {
        var defaults;
        if (options == null) {
          options = {}
        }
        defaults = {
          method: 'GET',
          data: null,
          headers: {},
          async: true,
          username: null,
          password: null
        };
        options = objectAssign({}, defaults, options);
        return new this.constructor.Promise(function (_this) {
          return function (resolve, reject) {
            var e, header, ref, value, xhr;
            if (!XMLHttpRequest) {
              _this._handleError('browser', reject, null, "browser doesn't support XMLHttpRequest");
              return
            }
            if (typeof options.url !== 'string' || options.url.length === 0) {
              _this._handleError('url', reject, null, 'URL is a required parameter');
              return
            }
            _this._xhr = xhr = new XMLHttpRequest;
            xhr.onload = function () {
              var responseText;
              _this._detachWindowUnload();
              try {
                responseText = _this._getResponseText()
              } catch (_error) {
                _this._handleError('parse', reject, null, 'invalid JSON response');
                return
              }
              return resolve({
                url: _this._getResponseUrl(),
                status: xhr.status,
                statusText: xhr.statusText,
                responseText: responseText,
                headers: _this._getHeaders(),
                xhr: xhr
              })
            };
            xhr.onerror = function () {
              return _this._handleError('error', reject)
            };
            xhr.ontimeout = function () {
              return _this._handleError('timeout', reject)
            };
            xhr.onabort = function () {
              return _this._handleError('abort', reject)
            };
            _this._attachWindowUnload();
            xhr.open(options.method, options.url, options.async, options.username, options.password);
            if (options.data != null && !options.headers['Content-Type']) {
              options.headers['Content-Type'] = _this.constructor.DEFAULT_CONTENT_TYPE
            }
            ref = options.headers;
            for (header in ref) {
              value = ref[header];
              xhr.setRequestHeader(header, value)
            }
            try {
              return xhr.send(options.data)
            } catch (_error) {
              e = _error;
              return _this._handleError('send', reject, null, e.toString())
            }
          }
        }(this))
      };
      /*
   * XMLHttpRequestPromise.getXHR() -> XMLHttpRequest
   */
      XMLHttpRequestPromise.prototype.getXHR = function () {
        return this._xhr
      };
      /*
   * XMLHttpRequestPromise._attachWindowUnload()
   *
   * Fix for IE 9 and IE 10
   * Internet Explorer freezes when you close a webpage during an XHR request
   * https://support.microsoft.com/kb/2856746
   *
   */
      XMLHttpRequestPromise.prototype._attachWindowUnload = function () {
        this._unloadHandler = this._handleWindowUnload.bind(this);
        if (window.attachEvent) {
          return window.attachEvent('onunload', this._unloadHandler)
        }
      };
      /*
   * XMLHttpRequestPromise._detachWindowUnload()
   */
      XMLHttpRequestPromise.prototype._detachWindowUnload = function () {
        if (window.detachEvent) {
          return window.detachEvent('onunload', this._unloadHandler)
        }
      };
      /*
   * XMLHttpRequestPromise._getHeaders() -> Object
   */
      XMLHttpRequestPromise.prototype._getHeaders = function () {
        return ParseHeaders(this._xhr.getAllResponseHeaders())
      };
      /*
   * XMLHttpRequestPromise._getResponseText() -> Mixed
   *
   * Parses response text JSON if present.
   */
      XMLHttpRequestPromise.prototype._getResponseText = function () {
        var responseText;
        responseText = typeof this._xhr.responseText === 'string' ? this._xhr.responseText : '';
        switch (this._xhr.getResponseHeader('Content-Type')) {
        case 'application/json':
        case 'text/javascript':
          responseText = JSON.parse(responseText + '')
        }
        return responseText
      };
      /*
   * XMLHttpRequestPromise._getResponseUrl() -> String
   *
   * Actual response URL after following redirects.
   */
      XMLHttpRequestPromise.prototype._getResponseUrl = function () {
        if (this._xhr.responseURL != null) {
          return this._xhr.responseURL
        }
        if (/^X-Request-URL:/m.test(this._xhr.getAllResponseHeaders())) {
          return this._xhr.getResponseHeader('X-Request-URL')
        }
        return ''
      };
      /*
   * XMLHttpRequestPromise._handleError(reason, reject, status, statusText)
   * - reason (String)
   * - reject (Function)
   * - status (String)
   * - statusText (String)
   */
      XMLHttpRequestPromise.prototype._handleError = function (reason, reject, status, statusText) {
        this._detachWindowUnload();
        return reject({
          reason: reason,
          status: status || this._xhr.status,
          statusText: statusText || this._xhr.statusText,
          xhr: this._xhr
        })
      };
      /*
   * XMLHttpRequestPromise._handleWindowUnload()
   */
      XMLHttpRequestPromise.prototype._handleWindowUnload = function () {
        return this._xhr.abort()
      };
      return XMLHttpRequestPromise
    }()
  });
  // source: node_modules/parse-headers/parse-headers.js
  require.define('parse-headers/parse-headers', function (module, exports, __dirname, __filename, process) {
    var trim = require('trim'), forEach = require('for-each'), isArray = function (arg) {
        return Object.prototype.toString.call(arg) === '[object Array]'
      };
    module.exports = function (headers) {
      if (!headers)
        return {};
      var result = {};
      forEach(trim(headers).split('\n'), function (row) {
        var index = row.indexOf(':'), key = trim(row.slice(0, index)).toLowerCase(), value = trim(row.slice(index + 1));
        if (typeof result[key] === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [
            result[key],
            value
          ]
        }
      });
      return result
    }
  });
  // source: node_modules/trim/index.js
  require.define('trim', function (module, exports, __dirname, __filename, process) {
    exports = module.exports = trim;
    function trim(str) {
      return str.replace(/^\s*|\s*$/g, '')
    }
    exports.left = function (str) {
      return str.replace(/^\s*/, '')
    };
    exports.right = function (str) {
      return str.replace(/\s*$/, '')
    }
  });
  // source: node_modules/for-each/index.js
  require.define('for-each', function (module, exports, __dirname, __filename, process) {
    var isFunction = require('is-function');
    module.exports = forEach;
    var toString = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function forEach(list, iterator, context) {
      if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
      }
      if (arguments.length < 3) {
        context = this
      }
      if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context);
      else if (typeof list === 'string')
        forEachString(list, iterator, context);
      else
        forEachObject(list, iterator, context)
    }
    function forEachArray(array, iterator, context) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          iterator.call(context, array[i], i, array)
        }
      }
    }
    function forEachString(string, iterator, context) {
      for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
      }
    }
    function forEachObject(object, iterator, context) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          iterator.call(context, object[k], k, object)
        }
      }
    }
  });
  // source: node_modules/is-function/index.js
  require.define('is-function', function (module, exports, __dirname, __filename, process) {
    module.exports = isFunction;
    var toString = Object.prototype.toString;
    function isFunction(fn) {
      var string = toString.call(fn);
      return string === '[object Function]' || typeof fn === 'function' && string !== '[object RegExp]' || typeof window !== 'undefined' && (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt)
    }
    ;
  });
  // source: node_modules/object-assign/index.js
  require.define('object-assign', function (module, exports, __dirname, __filename, process) {
    /* eslint-disable no-unused-vars */
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === undefined) {
        throw new TypeError('Object.assign cannot be called with null or undefined')
      }
      return Object(val)
    }
    module.exports = Object.assign || function (target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key]
          }
        }
        if (Object.getOwnPropertySymbols) {
          symbols = Object.getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]]
            }
          }
        }
      }
      return to
    }
  });
  // source: node_modules/page/index.js
  require.define('page', function (module, exports, __dirname, __filename, process) {
    /* globals require, module */
    'use strict';
    /**
   * Module dependencies.
   */
    var pathtoRegexp = require('path-to-regexp');
    /**
   * Module exports.
   */
    module.exports = page;
    /**
   * Detect click event
   */
    var clickEvent = 'undefined' !== typeof document && document.ontouchstart ? 'touchstart' : 'click';
    /**
   * To work properly with the URL
   * history.location generated polyfill in https://github.com/devote/HTML5-History-API
   */
    var location = 'undefined' !== typeof window && (window.history.location || window.location);
    /**
   * Perform initial dispatch.
   */
    var dispatch = true;
    /**
   * Decode URL components (query string, pathname, hash).
   * Accommodates both regular percent encoding and x-www-form-urlencoded format.
   */
    var decodeURLComponents = true;
    /**
   * Base path.
   */
    var base = '';
    /**
   * Running flag.
   */
    var running;
    /**
   * HashBang option
   */
    var hashbang = false;
    /**
   * Previous context, for capturing
   * page exit events.
   */
    var prevContext;
    /**
   * Register `path` with callback `fn()`,
   * or route `path`, or redirection,
   * or `page.start()`.
   *
   *   page(fn);
   *   page('*', fn);
   *   page('/user/:id', load, user);
   *   page('/user/' + user.id, { some: 'thing' });
   *   page('/user/' + user.id);
   *   page('/from', '/to')
   *   page();
   *
   * @param {string|!Function|!Object} path
   * @param {Function=} fn
   * @api public
   */
    function page(path, fn) {
      // <callback>
      if ('function' === typeof path) {
        return page('*', path)
      }
      // route <path> to <callback ...>
      if ('function' === typeof fn) {
        var route = new Route(path);
        for (var i = 1; i < arguments.length; ++i) {
          page.callbacks.push(route.middleware(arguments[i]))
        }  // show <path> with [state]
      } else if ('string' === typeof path) {
        page['string' === typeof fn ? 'redirect' : 'show'](path, fn)  // start [options]
      } else {
        page.start(path)
      }
    }
    /**
   * Callback functions.
   */
    page.callbacks = [];
    page.exits = [];
    /**
   * Current path being processed
   * @type {string}
   */
    page.current = '';
    /**
   * Number of pages navigated to.
   * @type {number}
   *
   *     page.len == 0;
   *     page('/login');
   *     page.len == 1;
   */
    page.len = 0;
    /**
   * Get or set basepath to `path`.
   *
   * @param {string} path
   * @api public
   */
    page.base = function (path) {
      if (0 === arguments.length)
        return base;
      base = path
    };
    /**
   * Bind with the given `options`.
   *
   * Options:
   *
   *    - `click` bind to click events [true]
   *    - `popstate` bind to popstate [true]
   *    - `dispatch` perform initial dispatch [true]
   *
   * @param {Object} options
   * @api public
   */
    page.start = function (options) {
      options = options || {};
      if (running)
        return;
      running = true;
      if (false === options.dispatch)
        dispatch = false;
      if (false === options.decodeURLComponents)
        decodeURLComponents = false;
      if (false !== options.popstate)
        window.addEventListener('popstate', onpopstate, false);
      if (false !== options.click) {
        document.addEventListener(clickEvent, onclick, false)
      }
      if (true === options.hashbang)
        hashbang = true;
      if (!dispatch)
        return;
      var url = hashbang && ~location.hash.indexOf('#!') ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;
      page.replace(url, null, true, dispatch)
    };
    /**
   * Unbind click and popstate event handlers.
   *
   * @api public
   */
    page.stop = function () {
      if (!running)
        return;
      page.current = '';
      page.len = 0;
      running = false;
      document.removeEventListener(clickEvent, onclick, false);
      window.removeEventListener('popstate', onpopstate, false)
    };
    /**
   * Show `path` with optional `state` object.
   *
   * @param {string} path
   * @param {Object=} state
   * @param {boolean=} dispatch
   * @param {boolean=} push
   * @return {!Context}
   * @api public
   */
    page.show = function (path, state, dispatch, push) {
      var ctx = new Context(path, state);
      page.current = ctx.path;
      if (false !== dispatch)
        page.dispatch(ctx);
      if (false !== ctx.handled && false !== push)
        ctx.pushState();
      return ctx
    };
    /**
   * Goes back in the history
   * Back should always let the current route push state and then go back.
   *
   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base
   * @param {Object=} state
   * @api public
   */
    page.back = function (path, state) {
      if (page.len > 0) {
        // this may need more testing to see if all browsers
        // wait for the next tick to go back in history
        history.back();
        page.len--
      } else if (path) {
        setTimeout(function () {
          page.show(path, state)
        })
      } else {
        setTimeout(function () {
          page.show(base, state)
        })
      }
    };
    /**
   * Register route to redirect from one path to other
   * or just redirect to another route
   *
   * @param {string} from - if param 'to' is undefined redirects to 'from'
   * @param {string=} to
   * @api public
   */
    page.redirect = function (from, to) {
      // Define route from a path to another
      if ('string' === typeof from && 'string' === typeof to) {
        page(from, function (e) {
          setTimeout(function () {
            page.replace(to)
          }, 0)
        })
      }
      // Wait for the push state and replace it with another
      if ('string' === typeof from && 'undefined' === typeof to) {
        setTimeout(function () {
          page.replace(from)
        }, 0)
      }
    };
    /**
   * Replace `path` with optional `state` object.
   *
   * @param {string} path
   * @param {Object=} state
   * @param {boolean=} init
   * @param {boolean=} dispatch
   * @return {!Context}
   * @api public
   */
    page.replace = function (path, state, init, dispatch) {
      var ctx = new Context(path, state);
      page.current = ctx.path;
      ctx.init = init;
      ctx.save();
      // save before dispatching, which may redirect
      if (false !== dispatch)
        page.dispatch(ctx);
      return ctx
    };
    /**
   * Dispatch the given `ctx`.
   *
   * @param {Context} ctx
   * @api private
   */
    page.dispatch = function (ctx) {
      var prev = prevContext, i = 0, j = 0;
      prevContext = ctx;
      function nextExit() {
        var fn = page.exits[j++];
        if (!fn)
          return nextEnter();
        fn(prev, nextExit)
      }
      function nextEnter() {
        var fn = page.callbacks[i++];
        if (ctx.path !== page.current) {
          ctx.handled = false;
          return
        }
        if (!fn)
          return unhandled(ctx);
        fn(ctx, nextEnter)
      }
      if (prev) {
        nextExit()
      } else {
        nextEnter()
      }
    };
    /**
   * Unhandled `ctx`. When it's not the initial
   * popstate then redirect. If you wish to handle
   * 404s on your own use `page('*', callback)`.
   *
   * @param {Context} ctx
   * @api private
   */
    function unhandled(ctx) {
      if (ctx.handled)
        return;
      var current;
      if (hashbang) {
        current = base + location.hash.replace('#!', '')
      } else {
        current = location.pathname + location.search
      }
      if (current === ctx.canonicalPath)
        return;
      page.stop();
      ctx.handled = false;
      location.href = ctx.canonicalPath
    }
    /**
   * Register an exit route on `path` with
   * callback `fn()`, which will be called
   * on the previous context when a new
   * page is visited.
   */
    page.exit = function (path, fn) {
      if (typeof path === 'function') {
        return page.exit('*', path)
      }
      var route = new Route(path);
      for (var i = 1; i < arguments.length; ++i) {
        page.exits.push(route.middleware(arguments[i]))
      }
    };
    /**
   * Remove URL encoding from the given `str`.
   * Accommodates whitespace in both x-www-form-urlencoded
   * and regular percent-encoded form.
   *
   * @param {string} val - URL component to decode
   */
    function decodeURLEncodedURIComponent(val) {
      if (typeof val !== 'string') {
        return val
      }
      return decodeURLComponents ? decodeURIComponent(val.replace(/\+/g, ' ')) : val
    }
    /**
   * Initialize a new "request" `Context`
   * with the given `path` and optional initial `state`.
   *
   * @constructor
   * @param {string} path
   * @param {Object=} state
   * @api public
   */
    function Context(path, state) {
      if ('/' === path[0] && 0 !== path.indexOf(base))
        path = base + (hashbang ? '#!' : '') + path;
      var i = path.indexOf('?');
      this.canonicalPath = path;
      this.path = path.replace(base, '') || '/';
      if (hashbang)
        this.path = this.path.replace('#!', '') || '/';
      this.title = document.title;
      this.state = state || {};
      this.state.path = path;
      this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';
      this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);
      this.params = {};
      // fragment
      this.hash = '';
      if (!hashbang) {
        if (!~this.path.indexOf('#'))
          return;
        var parts = this.path.split('#');
        this.path = parts[0];
        this.hash = decodeURLEncodedURIComponent(parts[1]) || '';
        this.querystring = this.querystring.split('#')[0]
      }
    }
    /**
   * Expose `Context`.
   */
    page.Context = Context;
    /**
   * Push state.
   *
   * @api private
   */
    Context.prototype.pushState = function () {
      page.len++;
      history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath)
    };
    /**
   * Save the context state.
   *
   * @api public
   */
    Context.prototype.save = function () {
      history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath)
    };
    /**
   * Initialize `Route` with the given HTTP `path`,
   * and an array of `callbacks` and `options`.
   *
   * Options:
   *
   *   - `sensitive`    enable case-sensitive routes
   *   - `strict`       enable strict matching for trailing slashes
   *
   * @constructor
   * @param {string} path
   * @param {Object=} options
   * @api private
   */
    function Route(path, options) {
      options = options || {};
      this.path = path === '*' ? '(.*)' : path;
      this.method = 'GET';
      this.regexp = pathtoRegexp(this.path, this.keys = [], options)
    }
    /**
   * Expose `Route`.
   */
    page.Route = Route;
    /**
   * Return route middleware with
   * the given callback `fn()`.
   *
   * @param {Function} fn
   * @return {Function}
   * @api public
   */
    Route.prototype.middleware = function (fn) {
      var self = this;
      return function (ctx, next) {
        if (self.match(ctx.path, ctx.params))
          return fn(ctx, next);
        next()
      }
    };
    /**
   * Check if this route matches `path`, if so
   * populate `params`.
   *
   * @param {string} path
   * @param {Object} params
   * @return {boolean}
   * @api private
   */
    Route.prototype.match = function (path, params) {
      var keys = this.keys, qsIndex = path.indexOf('?'), pathname = ~qsIndex ? path.slice(0, qsIndex) : path, m = this.regexp.exec(decodeURIComponent(pathname));
      if (!m)
        return false;
      for (var i = 1, len = m.length; i < len; ++i) {
        var key = keys[i - 1];
        var val = decodeURLEncodedURIComponent(m[i]);
        if (val !== undefined || !hasOwnProperty.call(params, key.name)) {
          params[key.name] = val
        }
      }
      return true
    };
    /**
   * Handle "populate" events.
   */
    var onpopstate = function () {
      var loaded = false;
      if ('undefined' === typeof window) {
        return
      }
      if (document.readyState === 'complete') {
        loaded = true
      } else {
        window.addEventListener('load', function () {
          setTimeout(function () {
            loaded = true
          }, 0)
        })
      }
      return function onpopstate(e) {
        if (!loaded)
          return;
        if (e.state) {
          var path = e.state.path;
          page.replace(path, e.state)
        } else {
          page.show(location.pathname + location.hash, undefined, undefined, false)
        }
      }
    }();
    /**
   * Handle "click" events.
   */
    function onclick(e) {
      if (1 !== which(e))
        return;
      if (e.metaKey || e.ctrlKey || e.shiftKey)
        return;
      if (e.defaultPrevented)
        return;
      // ensure link
      var el = e.target;
      while (el && 'A' !== el.nodeName)
        el = el.parentNode;
      if (!el || 'A' !== el.nodeName)
        return;
      // Ignore if tag has
      // 1. "download" attribute
      // 2. rel="external" attribute
      if (el.hasAttribute('download') || el.getAttribute('rel') === 'external')
        return;
      // ensure non-hash for the same path
      var link = el.getAttribute('href');
      if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link))
        return;
      // Check for mailto: in the href
      if (link && link.indexOf('mailto:') > -1)
        return;
      // check target
      if (el.target)
        return;
      // x-origin
      if (!sameOrigin(el.href))
        return;
      // rebuild path
      var path = el.pathname + el.search + (el.hash || '');
      // strip leading "/[drive letter]:" on NW.js on Windows
      if (typeof process !== 'undefined' && path.match(/^\/[a-zA-Z]:\//)) {
        path = path.replace(/^\/[a-zA-Z]:\//, '/')
      }
      // same page
      var orig = path;
      if (path.indexOf(base) === 0) {
        path = path.substr(base.length)
      }
      if (hashbang)
        path = path.replace('#!', '');
      if (base && orig === path)
        return;
      e.preventDefault();
      page.show(orig)
    }
    /**
   * Event button.
   */
    function which(e) {
      e = e || window.event;
      return null === e.which ? e.button : e.which
    }
    /**
   * Check if `href` is the same origin.
   */
    function sameOrigin(href) {
      var origin = location.protocol + '//' + location.hostname;
      if (location.port)
        origin += ':' + location.port;
      return href && 0 === href.indexOf(origin)
    }
    page.sameOrigin = sameOrigin
  });
  // source: node_modules/path-to-regexp/index.js
  require.define('path-to-regexp', function (module, exports, __dirname, __filename, process) {
    var isarray = require('isarray');
    /**
 * Expose `pathToRegexp`.
 */
    module.exports = pathToRegexp;
    module.exports.parse = parse;
    module.exports.compile = compile;
    module.exports.tokensToFunction = tokensToFunction;
    module.exports.tokensToRegExp = tokensToRegExp;
    /**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
    var PATH_REGEXP = new RegExp([
      // Match escaped characters that would otherwise appear in future matches.
      // This allows the user to escape special characters that won't transform.
      '(\\\\.)',
      // Match Express-style parameters and un-named parameters with a prefix
      // and optional suffixes. Matches appear as:
      //
      // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
      // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
      // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
      '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))'
    ].join('|'), 'g');
    /**
 * Parse a string for the raw tokens.
 *
 * @param  {String} str
 * @return {Array}
 */
    function parse(str) {
      var tokens = [];
      var key = 0;
      var index = 0;
      var path = '';
      var res;
      while ((res = PATH_REGEXP.exec(str)) != null) {
        var m = res[0];
        var escaped = res[1];
        var offset = res.index;
        path += str.slice(index, offset);
        index = offset + m.length;
        // Ignore already escaped sequences.
        if (escaped) {
          path += escaped[1];
          continue
        }
        // Push the current path onto the tokens.
        if (path) {
          tokens.push(path);
          path = ''
        }
        var prefix = res[2];
        var name = res[3];
        var capture = res[4];
        var group = res[5];
        var suffix = res[6];
        var asterisk = res[7];
        var repeat = suffix === '+' || suffix === '*';
        var optional = suffix === '?' || suffix === '*';
        var delimiter = prefix || '/';
        var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');
        tokens.push({
          name: name || key++,
          prefix: prefix || '',
          delimiter: delimiter,
          optional: optional,
          repeat: repeat,
          pattern: escapeGroup(pattern)
        })
      }
      // Match any characters still remaining.
      if (index < str.length) {
        path += str.substr(index)
      }
      // If the path exists, push it onto the end.
      if (path) {
        tokens.push(path)
      }
      return tokens
    }
    /**
 * Compile a string to a template function for the path.
 *
 * @param  {String}   str
 * @return {Function}
 */
    function compile(str) {
      return tokensToFunction(parse(str))
    }
    /**
 * Expose a method for transforming tokens into the path function.
 */
    function tokensToFunction(tokens) {
      // Compile all the tokens into regexps.
      var matches = new Array(tokens.length);
      // Compile all the patterns before compilation.
      for (var i = 0; i < tokens.length; i++) {
        if (typeof tokens[i] === 'object') {
          matches[i] = new RegExp('^' + tokens[i].pattern + '$')
        }
      }
      return function (obj) {
        var path = '';
        var data = obj || {};
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          if (typeof token === 'string') {
            path += token;
            continue
          }
          var value = data[token.name];
          var segment;
          if (value == null) {
            if (token.optional) {
              continue
            } else {
              throw new TypeError('Expected "' + token.name + '" to be defined')
            }
          }
          if (isarray(value)) {
            if (!token.repeat) {
              throw new TypeError('Expected "' + token.name + '" to not repeat, but received "' + value + '"')
            }
            if (value.length === 0) {
              if (token.optional) {
                continue
              } else {
                throw new TypeError('Expected "' + token.name + '" to not be empty')
              }
            }
            for (var j = 0; j < value.length; j++) {
              segment = encodeURIComponent(value[j]);
              if (!matches[i].test(segment)) {
                throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
              }
              path += (j === 0 ? token.prefix : token.delimiter) + segment
            }
            continue
          }
          segment = encodeURIComponent(value);
          if (!matches[i].test(segment)) {
            throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
          }
          path += token.prefix + segment
        }
        return path
      }
    }
    /**
 * Escape a regular expression string.
 *
 * @param  {String} str
 * @return {String}
 */
    function escapeString(str) {
      return str.replace(/([.+*?=^!:${}()[\]|\/])/g, '\\$1')
    }
    /**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
    function escapeGroup(group) {
      return group.replace(/([=!:$\/()])/g, '\\$1')
    }
    /**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
    function attachKeys(re, keys) {
      re.keys = keys;
      return re
    }
    /**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {String}
 */
    function flags(options) {
      return options.sensitive ? '' : 'i'
    }
    /**
 * Pull out keys from a regexp.
 *
 * @param  {RegExp} path
 * @param  {Array}  keys
 * @return {RegExp}
 */
    function regexpToRegexp(path, keys) {
      // Use a negative lookahead to match only capturing groups.
      var groups = path.source.match(/\((?!\?)/g);
      if (groups) {
        for (var i = 0; i < groups.length; i++) {
          keys.push({
            name: i,
            prefix: null,
            delimiter: null,
            optional: false,
            repeat: false,
            pattern: null
          })
        }
      }
      return attachKeys(path, keys)
    }
    /**
 * Transform an array into a regexp.
 *
 * @param  {Array}  path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
    function arrayToRegexp(path, keys, options) {
      var parts = [];
      for (var i = 0; i < path.length; i++) {
        parts.push(pathToRegexp(path[i], keys, options).source)
      }
      var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
      return attachKeys(regexp, keys)
    }
    /**
 * Create a path regexp from string input.
 *
 * @param  {String} path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
    function stringToRegexp(path, keys, options) {
      var tokens = parse(path);
      var re = tokensToRegExp(tokens, options);
      // Attach keys back to the regexp.
      for (var i = 0; i < tokens.length; i++) {
        if (typeof tokens[i] !== 'string') {
          keys.push(tokens[i])
        }
      }
      return attachKeys(re, keys)
    }
    /**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {Array}  tokens
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
    function tokensToRegExp(tokens, options) {
      options = options || {};
      var strict = options.strict;
      var end = options.end !== false;
      var route = '';
      var lastToken = tokens[tokens.length - 1];
      var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken);
      // Iterate over the tokens and create our regexp string.
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (typeof token === 'string') {
          route += escapeString(token)
        } else {
          var prefix = escapeString(token.prefix);
          var capture = token.pattern;
          if (token.repeat) {
            capture += '(?:' + prefix + capture + ')*'
          }
          if (token.optional) {
            if (prefix) {
              capture = '(?:' + prefix + '(' + capture + '))?'
            } else {
              capture = '(' + capture + ')?'
            }
          } else {
            capture = prefix + '(' + capture + ')'
          }
          route += capture
        }
      }
      // In non-strict mode we allow a slash at the end of match. If the path to
      // match already ends with a slash, we remove it for consistency. The slash
      // is valid at the end of a path match, not in the middle. This is important
      // in non-ending mode, where "/test/" shouldn't match "/test//route".
      if (!strict) {
        route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?'
      }
      if (end) {
        route += '$'
      } else {
        // In non-ending mode, we need the capturing groups to match as much as
        // possible by using a positive lookahead to the end or next path segment.
        route += strict && endsWithSlash ? '' : '(?=\\/|$)'
      }
      return new RegExp('^' + route, flags(options))
    }
    /**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 [keys]
 * @param  {Object}                [options]
 * @return {RegExp}
 */
    function pathToRegexp(path, keys, options) {
      keys = keys || [];
      if (!isarray(keys)) {
        options = keys;
        keys = []
      } else if (!options) {
        options = {}
      }
      if (path instanceof RegExp) {
        return regexpToRegexp(path, keys, options)
      }
      if (isarray(path)) {
        return arrayToRegexp(path, keys, options)
      }
      return stringToRegexp(path, keys, options)
    }
  });
  // source: node_modules/path-to-regexp/node_modules/isarray/index.js
  require.define('isarray', function (module, exports, __dirname, __filename, process) {
    module.exports = Array.isArray || function (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]'
    }
  });
  // source: src/index.coffee
  require.define('daisho', function (module, exports, __dirname, __filename, process) {
    var Promise, Xhr, exports, page;
    Promise = require('broken/lib');
    Xhr = require('xhr-promise-es6/lib');
    Xhr.Promise = Promise;
    page = require('page');
    require.urlFor = function (file) {
      return '/example/fixtures/' + file
    };
    exports = {
      basePath: '',
      moduleDefinitions: [],
      modulesRequired: [],
      modules: {},
      moduleList: [],
      renderElement: null,
      started: false,
      init: function (basePath, modulesUrl) {
        var opts;
        this.basePath = basePath;
        this.modulesUrl = modulesUrl;
        page.base(this.basePath);
        opts = {
          url: this.modulesUrl,
          method: 'GET'
        };
        return new Xhr().send(opts).then(function (_this) {
          return function (res) {
            _this.moduleDefinitions = res.responseText;
            return _this.moduleDefinitions
          }
        }(this))['catch'](function (res) {
          return console.log('ERROR:', res)
        })
      },
      setRenderElement: function (renderElement) {
        this.renderElement = renderElement
      },
      load: function (modulesRequired, opts) {
        this.modulesRequired = modulesRequired;
        return new Promise(function (_this) {
          return function (resolve, reject) {
            var fn, i, len, module, moduleList, moduleRequired, modules, ref, timeoutId, waits;
            timeoutId = setTimeout(function () {
              return reject(new Error('Loading Timed Out'))
            }, 10000);
            waits = 0;
            _this.modules = modules = {};
            _this.moduleList = moduleList = [];
            ref = _this.modulesRequired;
            fn = function (module, modules, moduleList) {
              var m;
              m = {};
              m.definition = module;
              moduleList.push(m);
              modules[module.name] = m;
              return function (m) {
                require(module.name + '-v' + module.version + '/bundle.js', function (js) {
                  var fn1, p, r, ref1;
                  m.name = js.name;
                  m.js = js;
                  m.key = module.name;
                  waits--;
                  clearTimeout(timeoutId);
                  ref1 = js.prototype.routes;
                  fn1 = function (r, p) {
                    return page('/' + module.name + r, function () {
                      var moduleInstance, ref2, ref3;
                      moduleInstance = new js;
                      if (_this.activeModuleInstance !== moduleInstance) {
                        if ((ref2 = _this.activeModuleInstance) != null ? ref2.unload : void 0) {
                          _this.activeModuleInstance.unload()
                        }
                        _this.activeModuleInstance = moduleInstance;
                        _this.activeModuleInstance.load(opts)
                      }
                      if ((ref3 = _this.activePageInstance) != null ? ref3.unload : void 0) {
                        _this.activePageInstance.unload();
                        while (_this.renderElement.firstChild != null) {
                          _this.renderElement.removeChild(_this.renderElement.firstChild)
                        }
                      }
                      _this.activePageInstance = new p(_this.renderElement, _this.activeModuleInstance);
                      _this.activePageInstance.load(opts);
                      return _this.activePageInstance.render()
                    })
                  };
                  for (r in ref1) {
                    p = ref1[r];
                    if (r === '/') {
                      r = ''
                    }
                    fn1(r, p)
                  }
                  if (waits === 0) {
                    return resolve({
                      modules: _this.modules,
                      moduleList: _this.moduleList
                    })
                  }
                });
                return m.css = module.name + '-v' + module.version + '/bundle.css'
              }(m)
            };
            for (i = 0, len = ref.length; i < len; i++) {
              moduleRequired = ref[i];
              module = _this._getModule(moduleRequired);
              waits++;
              fn(module, modules, moduleList)
            }
            if (waits === 0) {
              return p.resolve({
                modules: _this.modules,
                moduleList: _this.moduleList
              })
            }
          }
        }(this))
      },
      route: function (route) {
        if (!this.started) {
          this.started = true;
          page()
        }
        return page(this.basePath + '/' + route)
      },
      _getModule: function (moduleName) {
        var i, len, module, ref;
        ref = this.moduleDefinitions;
        for (i = 0, len = ref.length; i < len; i++) {
          module = ref[i];
          if (moduleName === module.name) {
            return module
          }
        }
      }
    };
    if (typeof window !== 'undefined' && window !== null) {
      window.Daisho = exports
    }
    module.exports = exports
  });
  require('daisho')
}.call(this, this))//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm9rZW4vbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3pvdXNhbi96b3VzYW4tbWluLmpzIiwibm9kZV9tb2R1bGVzL3hoci1wcm9taXNlLWVzNi9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9wYXJzZS1oZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzL3RyaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZnVuY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYWdlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwiaW5kZXguY29mZmVlIl0sIm5hbWVzIjpbIlByb21pc2UiLCJQcm9taXNlSW5zcGVjdGlvbiIsInJlcXVpcmUiLCJzdXBwcmVzc1VuY2F1Z2h0UmVqZWN0aW9uRXJyb3IiLCJhcmciLCJzdGF0ZSIsInZhbHVlIiwicmVhc29uIiwicHJvdG90eXBlIiwiaXNGdWxmaWxsZWQiLCJpc1JlamVjdGVkIiwicmVmbGVjdCIsInByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidGhlbiIsImVyciIsInNldHRsZSIsInByb21pc2VzIiwiYWxsIiwibWFwIiwiY2FsbGJhY2siLCJjYiIsImVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsInQiLCJlIiwibiIsInkiLCJjYWxsIiwiaSIsInAiLCJvIiwiciIsImMiLCJ1IiwicyIsImYiLCJsZW5ndGgiLCJzcGxpY2UiLCJNdXRhdGlvbk9ic2VydmVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJzZXRBdHRyaWJ1dGUiLCJzZXRJbW1lZGlhdGUiLCJzZXRUaW1lb3V0IiwicHVzaCIsIlR5cGVFcnJvciIsInYiLCJjb25zb2xlIiwibG9nIiwic3RhY2siLCJsIiwiYSIsInRpbWVvdXQiLCJFcnJvciIsIlpvdXNhbiIsInNvb24iLCJnbG9iYWwiLCJQYXJzZUhlYWRlcnMiLCJYTUxIdHRwUmVxdWVzdFByb21pc2UiLCJvYmplY3RBc3NpZ24iLCJERUZBVUxUX0NPTlRFTlRfVFlQRSIsInNlbmQiLCJvcHRpb25zIiwiZGVmYXVsdHMiLCJtZXRob2QiLCJkYXRhIiwiaGVhZGVycyIsImFzeW5jIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImNvbnN0cnVjdG9yIiwiX3RoaXMiLCJoZWFkZXIiLCJyZWYiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIl9oYW5kbGVFcnJvciIsInVybCIsIl94aHIiLCJvbmxvYWQiLCJyZXNwb25zZVRleHQiLCJfZGV0YWNoV2luZG93VW5sb2FkIiwiX2dldFJlc3BvbnNlVGV4dCIsIl9lcnJvciIsIl9nZXRSZXNwb25zZVVybCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJfZ2V0SGVhZGVycyIsIm9uZXJyb3IiLCJvbnRpbWVvdXQiLCJvbmFib3J0IiwiX2F0dGFjaFdpbmRvd1VubG9hZCIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwidG9TdHJpbmciLCJnZXRYSFIiLCJfdW5sb2FkSGFuZGxlciIsIl9oYW5kbGVXaW5kb3dVbmxvYWQiLCJiaW5kIiwid2luZG93IiwiYXR0YWNoRXZlbnQiLCJkZXRhY2hFdmVudCIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsImdldFJlc3BvbnNlSGVhZGVyIiwiSlNPTiIsInBhcnNlIiwicmVzcG9uc2VVUkwiLCJ0ZXN0IiwiYWJvcnQiLCJ0cmltIiwiZm9yRWFjaCIsImlzQXJyYXkiLCJPYmplY3QiLCJyZXN1bHQiLCJzcGxpdCIsInJvdyIsImluZGV4IiwiaW5kZXhPZiIsImtleSIsInNsaWNlIiwidG9Mb3dlckNhc2UiLCJzdHIiLCJyZXBsYWNlIiwibGVmdCIsInJpZ2h0IiwiaXNGdW5jdGlvbiIsImhhc093blByb3BlcnR5IiwibGlzdCIsIml0ZXJhdG9yIiwiY29udGV4dCIsImFyZ3VtZW50cyIsImZvckVhY2hBcnJheSIsImZvckVhY2hTdHJpbmciLCJmb3JFYWNoT2JqZWN0IiwiYXJyYXkiLCJsZW4iLCJzdHJpbmciLCJjaGFyQXQiLCJvYmplY3QiLCJrIiwiZm4iLCJhbGVydCIsImNvbmZpcm0iLCJwcm9tcHQiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsInZhbCIsInVuZGVmaW5lZCIsImFzc2lnbiIsInRhcmdldCIsInNvdXJjZSIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwYXRodG9SZWdleHAiLCJwYWdlIiwiY2xpY2tFdmVudCIsIm9udG91Y2hzdGFydCIsImxvY2F0aW9uIiwiaGlzdG9yeSIsImRpc3BhdGNoIiwiZGVjb2RlVVJMQ29tcG9uZW50cyIsImJhc2UiLCJydW5uaW5nIiwiaGFzaGJhbmciLCJwcmV2Q29udGV4dCIsInBhdGgiLCJyb3V0ZSIsIlJvdXRlIiwiY2FsbGJhY2tzIiwibWlkZGxld2FyZSIsInN0YXJ0IiwiZXhpdHMiLCJjdXJyZW50IiwicG9wc3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwib25wb3BzdGF0ZSIsImNsaWNrIiwib25jbGljayIsImhhc2giLCJzdWJzdHIiLCJzZWFyY2giLCJwYXRobmFtZSIsInN0b3AiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2hvdyIsImN0eCIsIkNvbnRleHQiLCJoYW5kbGVkIiwicHVzaFN0YXRlIiwiYmFjayIsInJlZGlyZWN0IiwiaW5pdCIsInNhdmUiLCJwcmV2IiwiaiIsIm5leHRFeGl0IiwibmV4dEVudGVyIiwidW5oYW5kbGVkIiwiY2Fub25pY2FsUGF0aCIsImhyZWYiLCJleGl0IiwiZGVjb2RlVVJMRW5jb2RlZFVSSUNvbXBvbmVudCIsImRlY29kZVVSSUNvbXBvbmVudCIsInRpdGxlIiwicXVlcnlzdHJpbmciLCJwYXJhbXMiLCJwYXJ0cyIsInJlcGxhY2VTdGF0ZSIsInJlZ2V4cCIsImtleXMiLCJzZWxmIiwibmV4dCIsIm1hdGNoIiwicXNJbmRleCIsIm0iLCJleGVjIiwibmFtZSIsImxvYWRlZCIsInJlYWR5U3RhdGUiLCJ3aGljaCIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJkZWZhdWx0UHJldmVudGVkIiwiZWwiLCJub2RlTmFtZSIsInBhcmVudE5vZGUiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJsaW5rIiwic2FtZU9yaWdpbiIsInByb2Nlc3MiLCJvcmlnIiwicHJldmVudERlZmF1bHQiLCJldmVudCIsImJ1dHRvbiIsIm9yaWdpbiIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0IiwiaXNhcnJheSIsInBhdGhUb1JlZ2V4cCIsImNvbXBpbGUiLCJ0b2tlbnNUb0Z1bmN0aW9uIiwidG9rZW5zVG9SZWdFeHAiLCJQQVRIX1JFR0VYUCIsIlJlZ0V4cCIsImpvaW4iLCJ0b2tlbnMiLCJyZXMiLCJlc2NhcGVkIiwib2Zmc2V0IiwicHJlZml4IiwiY2FwdHVyZSIsImdyb3VwIiwic3VmZml4IiwiYXN0ZXJpc2siLCJyZXBlYXQiLCJvcHRpb25hbCIsImRlbGltaXRlciIsInBhdHRlcm4iLCJlc2NhcGVHcm91cCIsIm1hdGNoZXMiLCJBcnJheSIsIm9iaiIsInRva2VuIiwic2VnbWVudCIsImVuY29kZVVSSUNvbXBvbmVudCIsImVzY2FwZVN0cmluZyIsImF0dGFjaEtleXMiLCJyZSIsImZsYWdzIiwic2Vuc2l0aXZlIiwicmVnZXhwVG9SZWdleHAiLCJncm91cHMiLCJhcnJheVRvUmVnZXhwIiwic3RyaW5nVG9SZWdleHAiLCJzdHJpY3QiLCJlbmQiLCJsYXN0VG9rZW4iLCJlbmRzV2l0aFNsYXNoIiwiYXJyIiwiWGhyIiwidXJsRm9yIiwiZmlsZSIsImJhc2VQYXRoIiwibW9kdWxlRGVmaW5pdGlvbnMiLCJtb2R1bGVzUmVxdWlyZWQiLCJtb2R1bGVzIiwibW9kdWxlTGlzdCIsInJlbmRlckVsZW1lbnQiLCJzdGFydGVkIiwibW9kdWxlc1VybCIsIm9wdHMiLCJzZXRSZW5kZXJFbGVtZW50IiwibG9hZCIsIm1vZHVsZVJlcXVpcmVkIiwidGltZW91dElkIiwid2FpdHMiLCJkZWZpbml0aW9uIiwidmVyc2lvbiIsImpzIiwiZm4xIiwicmVmMSIsImNsZWFyVGltZW91dCIsInJvdXRlcyIsIm1vZHVsZUluc3RhbmNlIiwicmVmMiIsInJlZjMiLCJhY3RpdmVNb2R1bGVJbnN0YW5jZSIsInVubG9hZCIsImFjdGl2ZVBhZ2VJbnN0YW5jZSIsImZpcnN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsInJlbmRlciIsImNzcyIsIl9nZXRNb2R1bGUiLCJtb2R1bGVOYW1lIiwiRGFpc2hvIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFDQTtBQUFBLFFBQUlBLE9BQUosRUFBYUMsaUJBQWIsQztJQUVBRCxPQUFBLEdBQVVFLE9BQUEsQ0FBUSxtQkFBUixDQUFWLEM7SUFFQUYsT0FBQSxDQUFRRyw4QkFBUixHQUF5QyxLQUF6QyxDO0lBRUFGLGlCQUFBLEdBQXFCLFlBQVc7QUFBQSxNQUM5QixTQUFTQSxpQkFBVCxDQUEyQkcsR0FBM0IsRUFBZ0M7QUFBQSxRQUM5QixLQUFLQyxLQUFMLEdBQWFELEdBQUEsQ0FBSUMsS0FBakIsRUFBd0IsS0FBS0MsS0FBTCxHQUFhRixHQUFBLENBQUlFLEtBQXpDLEVBQWdELEtBQUtDLE1BQUwsR0FBY0gsR0FBQSxDQUFJRyxNQURwQztBQUFBLE9BREY7QUFBQSxNQUs5Qk4saUJBQUEsQ0FBa0JPLFNBQWxCLENBQTRCQyxXQUE1QixHQUEwQyxZQUFXO0FBQUEsUUFDbkQsT0FBTyxLQUFLSixLQUFMLEtBQWUsV0FENkI7QUFBQSxPQUFyRCxDQUw4QjtBQUFBLE1BUzlCSixpQkFB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