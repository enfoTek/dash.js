(function (global) {
  var process = {
    title: 'browser',
    browser: true,
    env: {},
    argv: [],
    nextTick: function (fn) {
      setTimeout(fn, 0)
    },
    cwd: function () {
      return '/'
    },
    chdir: function () {
    }
  };
  // Require module
  function require(file, cb) {
    // Handle async require
    if (typeof cb == 'function') {
      return require.load(file, cb)
    }
    // Return module from cache
    if ({}.hasOwnProperty.call(require.cache, file))
      return require.cache[file];
    var resolved = require.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var mod = {
      id: file,
      require: require,
      filename: file,
      exports: {},
      loaded: false,
      parent: null,
      children: []
    };
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    require.cache[file] = mod.exports;
    resolved.call(mod.exports, mod, mod.exports, dirname, file, process);
    mod.loaded = true;
    return require.cache[file] = mod.exports
  }
  require.modules = {};
  require.cache = {};
  require.resolve = function (file) {
    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0
  };
  // define normal static module
  require.define = function (file, fn) {
    require.modules[file] = fn
  };
  require.waiting = {};
  // Determine base path for all modules
  var scripts = document.getElementsByTagName('script');
  var file = scripts[scripts.length - 1].src;
  require.basePath = file.slice(0, file.lastIndexOf('/') + 1);
  // Generate URL for module
  require.urlFor = function (file) {
    var url = file.replace(/^\.?\//, '');
    if (!/\.js$/.test(url))
      url = url + '.js';
    return require.basePath + url
  };
  // Load module async module
  require.load = function (file, cb) {
    // Immediately return previously loaded modules
    if (require.modules[file] != null)
      return cb(require(file));
    // Build URL to request module at
    var url = require.urlFor(file);
    var script = document.createElement('script'), scripts = document.getElementsByTagName('script')[0], callbacks = require.waiting[file] = require.waiting[file] || [];
    // We'll be called when async module is defined.
    callbacks.push(cb);
    // Load module
    script.type = 'text/javascript';
    script.async = true;
    script.src = url;
    script.file = file;
    scripts.parentNode.insertBefore(script, scripts)
  };
  // Define async module
  require.async = function (file, fn) {
    require.modules[file] = fn;
    var cb;
    while (cb = require.waiting[file].shift())
      cb(require(file))
  };
  global.require = require;
  // source: node_modules/broken/lib/index.js
  require.define('broken/lib', function (module, exports, __dirname, __filename, process) {
    // Generated by CoffeeScript 1.10.0
    var Promise, PromiseInspection;
    Promise = require('zousan/zousan-min');
    Promise.suppressUncaughtRejectionError = false;
    PromiseInspection = function () {
      function PromiseInspection(arg) {
        this.state = arg.state, this.value = arg.value, this.reason = arg.reason
      }
      PromiseInspection.prototype.isFulfilled = function () {
        return this.state === 'fulfilled'
      };
      PromiseInspection.prototype.isRejected = function () {
        return this.state === 'rejected'
      };
      return PromiseInspection
    }();
    Promise.reflect = function (promise) {
      return new Promise(function (resolve, reject) {
        return promise.then(function (value) {
          return resolve(new PromiseInspection({
            state: 'fulfilled',
            value: value
          }))
        })['catch'](function (err) {
          return resolve(new PromiseInspection({
            state: 'rejected',
            reason: err
          }))
        })
      })
    };
    Promise.settle = function (promises) {
      return Promise.all(promises.map(Promise.reflect))
    };
    Promise.prototype.callback = function (cb) {
      if (typeof cb === 'function') {
        this.then(function (value) {
          return cb(null, value)
        });
        this['catch'](function (error) {
          return cb(error, null)
        })
      }
      return this
    };
    module.exports = Promise  //# sourceMappingURL=index.js.map
  });
  // source: node_modules/zousan/zousan-min.js
  require.define('zousan/zousan-min', function (module, exports, __dirname, __filename, process) {
    !function (t) {
      'use strict';
      function e(t) {
        if (t) {
          var e = this;
          t(function (t) {
            e.resolve(t)
          }, function (t) {
            e.reject(t)
          })
        }
      }
      function n(t, e) {
        if ('function' == typeof t.y)
          try {
            var n = t.y.call(i, e);
            t.p.resolve(n)
          } catch (o) {
            t.p.reject(o)
          }
        else
          t.p.resolve(e)
      }
      function o(t, e) {
        if ('function' == typeof t.n)
          try {
            var n = t.n.call(i, e);
            t.p.resolve(n)
          } catch (o) {
            t.p.reject(o)
          }
        else
          t.p.reject(e)
      }
      var r, i, c = 'fulfilled', u = 'rejected', s = 'undefined', f = function () {
          function t() {
            for (; e.length - n;)
              e[n](), e[n++] = i, n == o && (e.splice(0, o), n = 0)
          }
          var e = [], n = 0, o = 1024, r = function () {
              if (typeof MutationObserver !== s) {
                var e = document.createElement('div'), n = new MutationObserver(t);
                return n.observe(e, { attributes: !0 }), function () {
                  e.setAttribute('a', 0)
                }
              }
              return typeof setImmediate !== s ? function () {
                setImmediate(t)
              } : function () {
                setTimeout(t, 0)
              }
            }();
          return function (t) {
            e.push(t), e.length - n == 1 && r()
          }
        }();
      e.prototype = {
        resolve: function (t) {
          if (this.state === r) {
            if (t === this)
              return this.reject(new TypeError('Attempt to resolve promise with self'));
            var e = this;
            if (t && ('function' == typeof t || 'object' == typeof t))
              try {
                var o = !0, i = t.then;
                if ('function' == typeof i)
                  return void i.call(t, function (t) {
                    o && (o = !1, e.resolve(t))
                  }, function (t) {
                    o && (o = !1, e.reject(t))
                  })
              } catch (u) {
                return void (o && this.reject(u))
              }
            this.state = c, this.v = t, e.c && f(function () {
              for (var o = 0, r = e.c.length; r > o; o++)
                n(e.c[o], t)
            })
          }
        },
        reject: function (t) {
          if (this.state === r) {
            this.state = u, this.v = t;
            var n = this.c;
            n ? f(function () {
              for (var e = 0, r = n.length; r > e; e++)
                o(n[e], t)
            }) : e.suppressUncaughtRejectionError || console.log('You upset Zousan. Please catch rejections: ', t, t.stack)
          }
        },
        then: function (t, i) {
          var u = new e, s = {
              y: t,
              n: i,
              p: u
            };
          if (this.state === r)
            this.c ? this.c.push(s) : this.c = [s];
          else {
            var l = this.state, a = this.v;
            f(function () {
              l === c ? n(s, a) : o(s, a)
            })
          }
          return u
        },
        'catch': function (t) {
          return this.then(null, t)
        },
        'finally': function (t) {
          return this.then(t, t)
        },
        timeout: function (t, n) {
          n = n || 'Timeout';
          var o = this;
          return new e(function (e, r) {
            setTimeout(function () {
              r(Error(n))
            }, t), o.then(function (t) {
              e(t)
            }, function (t) {
              r(t)
            })
          })
        }
      }, e.resolve = function (t) {
        var n = new e;
        return n.resolve(t), n
      }, e.reject = function (t) {
        var n = new e;
        return n.reject(t), n
      }, e.all = function (t) {
        function n(n, c) {
          'function' != typeof n.then && (n = e.resolve(n)), n.then(function (e) {
            o[c] = e, r++, r == t.length && i.resolve(o)
          }, function (t) {
            i.reject(t)
          })
        }
        for (var o = [], r = 0, i = new e, c = 0; c < t.length; c++)
          n(t[c], c);
        return t.length || i.resolve(o), i
      }, typeof module != s && module.exports && (module.exports = e), t.Zousan = e, e.soon = f
    }('undefined' != typeof global ? global : this)
  });
  // source: node_modules/riot/riot.js
  require.define('riot/riot', function (module, exports, __dirname, __filename, process) {
    /* Riot v2.3.17, @license MIT */
    ;
    (function (window, undefined) {
      'use strict';
      var riot = {
          version: 'v2.3.17',
          settings: {}
        },
        // be aware, internal usage
        // ATTENTION: prefix the global dynamic variables with `__`
        // counter to give a unique id to all the Tag instances
        __uid = 0,
        // tags instances cache
        __virtualDom = [],
        // tags implementation cache
        __tagImpl = {},
        /**
   * Const
   */
        GLOBAL_MIXIN = '__global_mixin',
        // riot specific prefixes
        RIOT_PREFIX = 'riot-', RIOT_TAG = RIOT_PREFIX + 'tag', RIOT_TAG_IS = 'data-is',
        // for typeof == '' comparisons
        T_STRING = 'string', T_OBJECT = 'object', T_UNDEF = 'undefined', T_BOOL = 'boolean', T_FUNCTION = 'function',
        // special native tags that cannot be treated like the others
        SPECIAL_TAGS_REGEX = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/, RESERVED_WORDS_BLACKLIST = [
          '_item',
          '_id',
          '_parent',
          'update',
          'root',
          'mount',
          'unmount',
          'mixin',
          'isMounted',
          'isLoop',
          'tags',
          'parent',
          'opts',
          'trigger',
          'on',
          'off',
          'one'
        ],
        // version# for IE 8-11, 0 for others
        IE_VERSION = (window && window.document || {}).documentMode | 0;
      /* istanbul ignore next */
      riot.observable = function (el) {
        /**
   * Extend the original object or create a new empty one
   * @type { Object }
   */
        el = el || {};
        /**
   * Private variables and methods
   */
        var callbacks = {}, slice = Array.prototype.slice, onEachEvent = function (e, fn) {
            e.replace(/\S+/g, fn)
          };
        // extend the object adding the observable methods
        Object.defineProperties(el, {
          /**
     * Listen to the given space separated list of `events` and execute the `callback` each time an event is triggered.
     * @param  { String } events - events ids
     * @param  { Function } fn - callback function
     * @returns { Object } el
     */
          on: {
            value: function (events, fn) {
              if (typeof fn != 'function')
                return el;
              onEachEvent(events, function (name, pos) {
                (callbacks[name] = callbacks[name] || []).push(fn);
                fn.typed = pos > 0
              });
              return el
            },
            enumerable: false,
            writable: false,
            configurable: false
          },
          /**
     * Removes the given space separated list of `events` listeners
     * @param   { String } events - events ids
     * @param   { Function } fn - callback function
     * @returns { Object } el
     */
          off: {
            value: function (events, fn) {
              if (events == '*' && !fn)
                callbacks = {};
              else {
                onEachEvent(events, function (name) {
                  if (fn) {
                    var arr = callbacks[name];
                    for (var i = 0, cb; cb = arr && arr[i]; ++i) {
                      if (cb == fn)
                        arr.splice(i--, 1)
                    }
                  } else
                    delete callbacks[name]
                })
              }
              return el
            },
            enumerable: false,
            writable: false,
            configurable: false
          },
          /**
     * Listen to the given space separated list of `events` and execute the `callback` at most once
     * @param   { String } events - events ids
     * @param   { Function } fn - callback function
     * @returns { Object } el
     */
          one: {
            value: function (events, fn) {
              function on() {
                el.off(events, on);
                fn.apply(el, arguments)
              }
              return el.on(events, on)
            },
            enumerable: false,
            writable: false,
            configurable: false
          },
          /**
     * Execute all callback functions that listen to the given space separated list of `events`
     * @param   { String } events - events ids
     * @returns { Object } el
     */
          trigger: {
            value: function (events) {
              // getting the arguments
              var arglen = arguments.length - 1, args = new Array(arglen), fns;
              for (var i = 0; i < arglen; i++) {
                args[i] = arguments[i + 1]  // skip first argument
              }
              onEachEvent(events, function (name) {
                fns = slice.call(callbacks[name] || [], 0);
                for (var i = 0, fn; fn = fns[i]; ++i) {
                  if (fn.busy)
                    return;
                  fn.busy = 1;
                  fn.apply(el, fn.typed ? [name].concat(args) : args);
                  if (fns[i] !== fn) {
                    i--
                  }
                  fn.busy = 0
                }
                if (callbacks['*'] && name != '*')
                  el.trigger.apply(el, [
                    '*',
                    name
                  ].concat(args))
              });
              return el
            },
            enumerable: false,
            writable: false,
            configurable: false
          }
        });
        return el
      }  /* istanbul ignore next */;
      (function (riot) {
        /**
 * Simple client-side router
 * @module riot-route
 */
        var RE_ORIGIN = /^.+?\/+[^\/]+/, EVENT_LISTENER = 'EventListener', REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER, ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER, HAS_ATTRIBUTE = 'hasAttribute', REPLACE = 'replace', POPSTATE = 'popstate', HASHCHANGE = 'hashchange', TRIGGER = 'trigger', MAX_EMIT_STACK_LEVEL = 3, win = typeof window != 'undefined' && window, doc = typeof document != 'undefined' && document, hist = win && history, loc = win && (hist.location || win.location),
          // see html5-history-api
          prot = Router.prototype,
          // to minify more
          clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click', started = false, central = riot.observable(), routeFound = false, debouncedEmit, base, current, parser, secondParser, emitStack = [], emitStackLevel = 0;
        /**
 * Default parser. You can replace it via router.parser method.
 * @param {string} path - current path (normalized)
 * @returns {array} array
 */
        function DEFAULT_PARSER(path) {
          return path.split(/[\/?#]/)
        }
        /**
 * Default parser (second). You can replace it via router.parser method.
 * @param {string} path - current path (normalized)
 * @param {string} filter - filter string (normalized)
 * @returns {array} array
 */
        function DEFAULT_SECOND_PARSER(path, filter) {
          var re = new RegExp('^' + filter[REPLACE](/\*/g, '([^/?#]+?)')[REPLACE](/\.\./, '.*') + '$'), args = path.match(re);
          if (args)
            return args.slice(1)
        }
        /**
 * Simple/cheap debounce implementation
 * @param   {function} fn - callback
 * @param   {number} delay - delay in seconds
 * @returns {function} debounced function
 */
        function debounce(fn, delay) {
          var t;
          return function () {
            clearTimeout(t);
            t = setTimeout(fn, delay)
          }
        }
        /**
 * Set the window listeners to trigger the routes
 * @param {boolean} autoExec - see route.start
 */
        function start(autoExec) {
          debouncedEmit = debounce(emit, 1);
          win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit);
          win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit);
          doc[ADD_EVENT_LISTENER](clickEvent, click);
          if (autoExec)
            emit(true)
        }
        /**
 * Router class
 */
        function Router() {
          this.$ = [];
          riot.observable(this);
          // make it observable
          central.on('stop', this.s.bind(this));
          central.on('emit', this.e.bind(this))
        }
        function normalize(path) {
          return path[REPLACE](/^\/|\/$/, '')
        }
        function isString(str) {
          return typeof str == 'string'
        }
        /**
 * Get the part after domain name
 * @param {string} href - fullpath
 * @returns {string} path from root
 */
        function getPathFromRoot(href) {
          return (href || loc.href || '')[REPLACE](RE_ORIGIN, '')
        }
        /**
 * Get the part after base
 * @param {string} href - fullpath
 * @returns {string} path from base
 */
        function getPathFromBase(href) {
          return base[0] == '#' ? (href || loc.href || '').split(base)[1] || '' : getPathFromRoot(href)[REPLACE](base, '')
        }
        function emit(force) {
          // the stack is needed for redirections
          var isRoot = emitStackLevel == 0;
          if (MAX_EMIT_STACK_LEVEL <= emitStackLevel)
            return;
          emitStackLevel++;
          emitStack.push(function () {
            var path = getPathFromBase();
            if (force || path != current) {
              central[TRIGGER]('emit', path);
              current = path
            }
          });
          if (isRoot) {
            while (emitStack.length) {
              emitStack[0]();
              emitStack.shift()
            }
            emitStackLevel = 0
          }
        }
        function click(e) {
          if (e.which != 1  // not left click
|| e.metaKey || e.ctrlKey || e.shiftKey || e.defaultPrevented)
            return;
          var el = e.target;
          while (el && el.nodeName != 'A')
            el = el.parentNode;
          if (!el || el.nodeName != 'A'  // not A tag
|| el[HAS_ATTRIBUTE]('download')  // has download attr
|| !el[HAS_ATTRIBUTE]('href')  // has no href attr
|| el.target && el.target != '_self'  // another window or frame
|| el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1  // cross origin
)
            return;
          if (el.href != loc.href) {
            if (el.href.split('#')[0] == loc.href.split('#')[0]  // internal jump
|| base != '#' && getPathFromRoot(el.href).indexOf(base) !== 0  // outside of base
|| !go(getPathFromBase(el.href), el.title || doc.title)  // route not found
)
              return
          }
          e.preventDefault()
        }
        /**
 * Go to the path
 * @param {string} path - destination path
 * @param {string} title - page title
 * @param {boolean} shouldReplace - use replaceState or pushState
 * @returns {boolean} - route not found flag
 */
        function go(path, title, shouldReplace) {
          if (hist) {
            // if a browser
            path = base + normalize(path);
            title = title || doc.title;
            // browsers ignores the second parameter `title`
            shouldReplace ? hist.replaceState(null, title, path) : hist.pushState(null, title, path);
            // so we need to set it manually
            doc.title = title;
            routeFound = false;
            emit();
            return routeFound
          }
          // Server-side usage: directly execute handlers for the path
          return central[TRIGGER]('emit', getPathFromBase(path))
        }
        /**
 * Go to path or set action
 * a single string:                go there
 * two strings:                    go there with setting a title
 * two strings and boolean:        replace history with setting a title
 * a single function:              set an action on the default route
 * a string/RegExp and a function: set an action on the route
 * @param {(string|function)} first - path / action / filter
 * @param {(string|RegExp|function)} second - title / action
 * @param {boolean} third - replace flag
 */
        prot.m = function (first, second, third) {
          if (isString(first) && (!second || isString(second)))
            go(first, second, third || false);
          else if (second)
            this.r(first, second);
          else
            this.r('@', first)
        };
        /**
 * Stop routing
 */
        prot.s = function () {
          this.off('*');
          this.$ = []
        };
        /**
 * Emit
 * @param {string} path - path
 */
        prot.e = function (path) {
          this.$.concat('@').some(function (filter) {
            var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter));
            if (typeof args != 'undefined') {
              this[TRIGGER].apply(null, [filter].concat(args));
              return routeFound = true  // exit from loop
            }
          }, this)
        };
        /**
 * Register route
 * @param {string} filter - filter for matching to url
 * @param {function} action - action to register
 */
        prot.r = function (filter, action) {
          if (filter != '@') {
            filter = '/' + normalize(filter);
            this.$.push(filter)
          }
          this.on(filter, action)
        };
        var mainRouter = new Router;
        var route = mainRouter.m.bind(mainRouter);
        /**
 * Create a sub router
 * @returns {function} the method of a new Router object
 */
        route.create = function () {
          var newSubRouter = new Router;
          // stop only this sub-router
          newSubRouter.m.stop = newSubRouter.s.bind(newSubRouter);
          // return sub-router's main method
          return newSubRouter.m.bind(newSubRouter)
        };
        /**
 * Set the base of url
 * @param {(str|RegExp)} arg - a new base or '#' or '#!'
 */
        route.base = function (arg) {
          base = arg || '#';
          current = getPathFromBase()  // recalculate current path
        };
        /** Exec routing right now **/
        route.exec = function () {
          emit(true)
        };
        /**
 * Replace the default router to yours
 * @param {function} fn - your parser function
 * @param {function} fn2 - your secondParser function
 */
        route.parser = function (fn, fn2) {
          if (!fn && !fn2) {
            // reset parser for testing...
            parser = DEFAULT_PARSER;
            secondParser = DEFAULT_SECOND_PARSER
          }
          if (fn)
            parser = fn;
          if (fn2)
            secondParser = fn2
        };
        /**
 * Helper function to get url query as an object
 * @returns {object} parsed query
 */
        route.query = function () {
          var q = {};
          var href = loc.href || current;
          href[REPLACE](/[?&](.+?)=([^&]*)/g, function (_, k, v) {
            q[k] = v
          });
          return q
        };
        /** Stop routing **/
        route.stop = function () {
          if (started) {
            if (win) {
              win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit);
              win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit);
              doc[REMOVE_EVENT_LISTENER](clickEvent, click)
            }
            central[TRIGGER]('stop');
            started = false
          }
        };
        /**
 * Start routing
 * @param {boolean} autoExec - automatically exec after starting if true
 */
        route.start = function (autoExec) {
          if (!started) {
            if (win) {
              if (document.readyState == 'complete')
                start(autoExec)  // the timeout is needed to solve
                                 // a weird safari bug https://github.com/riot/route/issues/33
;
              else
                win[ADD_EVENT_LISTENER]('load', function () {
                  setTimeout(function () {
                    start(autoExec)
                  }, 1)
                })
            }
            started = true
          }
        };
        /** Prepare the router **/
        route.base();
        route.parser();
        riot.route = route
      }(riot));
      /* istanbul ignore next */
      /**
 * The riot template engine
 * @version v2.3.21
 */
      /**
 * riot.util.brackets
 *
 * - `brackets    ` - Returns a string or regex based on its parameter
 * - `brackets.set` - Change the current riot brackets
 *
 * @module
 */
      var brackets = function (UNDEF) {
        var REGLOB = 'g', R_MLCOMMS = /\/\*[^*]*\*+(?:[^*\/][^*]*\*+)*\//g, R_STRINGS = /"[^"\\]*(?:\\[\S\s][^"\\]*)*"|'[^'\\]*(?:\\[\S\s][^'\\]*)*'/g, S_QBLOCKS = R_STRINGS.source + '|' + /(?:\breturn\s+|(?:[$\w\)\]]|\+\+|--)\s*(\/)(?![*\/]))/.source + '|' + /\/(?=[^*\/])[^[\/\\]*(?:(?:\[(?:\\.|[^\]\\]*)*\]|\\.)[^[\/\\]*)*?(\/)[gim]*/.source, FINDBRACES = {
            '(': RegExp('([()])|' + S_QBLOCKS, REGLOB),
            '[': RegExp('([[\\]])|' + S_QBLOCKS, REGLOB),
            '{': RegExp('([{}])|' + S_QBLOCKS, REGLOB)
          }, DEFAULT = '{ }';
        var _pairs = [
          '{',
          '}',
          '{',
          '}',
          /{[^}]*}/,
          /\\([{}])/g,
          /\\({)|{/g,
          RegExp('\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),
          DEFAULT,
          /^\s*{\^?\s*([$\w]+)(?:\s*,\s*(\S+))?\s+in\s+(\S.*)\s*}/,
          /(^|[^\\]){=[\S\s]*?}/
        ];
        var cachedBrackets = UNDEF, _regex, _cache = [], _settings;
        function _loopback(re) {
          return re
        }
        function _rewrite(re, bp) {
          if (!bp)
            bp = _cache;
          return new RegExp(re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : '')
        }
        function _create(pair) {
          if (pair === DEFAULT)
            return _pairs;
          var arr = pair.split(' ');
          if (arr.length !== 2 || /[\x00-\x1F<>a-zA-Z0-9'",;\\]/.test(pair)) {
            throw new Error('Unsupported brackets "' + pair + '"')
          }
          arr = arr.concat(pair.replace(/(?=[[\]()*+?.^$|])/g, '\\').split(' '));
          arr[4] = _rewrite(arr[1].length > 1 ? /{[\S\s]*?}/ : _pairs[4], arr);
          arr[5] = _rewrite(pair.length > 3 ? /\\({|})/g : _pairs[5], arr);
          arr[6] = _rewrite(_pairs[6], arr);
          arr[7] = RegExp('\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB);
          arr[8] = pair;
          return arr
        }
        function _brackets(reOrIdx) {
          return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]
        }
        _brackets.split = function split(str, tmpl, _bp) {
          // istanbul ignore next: _bp is for the compiler
          if (!_bp)
            _bp = _cache;
          var parts = [], match, isexpr, start, pos, re = _bp[6];
          isexpr = start = re.lastIndex = 0;
          while (match = re.exec(str)) {
            pos = match.index;
            if (isexpr) {
              if (match[2]) {
                re.lastIndex = skipBraces(str, match[2], re.lastIndex);
                continue
              }
              if (!match[3])
                continue
            }
            if (!match[1]) {
              unescapeStr(str.slice(start, pos));
              start = re.lastIndex;
              re = _bp[6 + (isexpr ^= 1)];
              re.lastIndex = start
            }
          }
          if (str && start < str.length) {
            unescapeStr(str.slice(start))
          }
          return parts;
          function unescapeStr(s) {
            if (tmpl || isexpr)
              parts.push(s && s.replace(_bp[5], '$1'));
            else
              parts.push(s)
          }
          function skipBraces(s, ch, ix) {
            var match, recch = FINDBRACES[ch];
            recch.lastIndex = ix;
            ix = 1;
            while (match = recch.exec(s)) {
              if (match[1] && !(match[1] === ch ? ++ix : --ix))
                break
            }
            return ix ? s.length : recch.lastIndex
          }
        };
        _brackets.hasExpr = function hasExpr(str) {
          return _cache[4].test(str)
        };
        _brackets.loopKeys = function loopKeys(expr) {
          var m = expr.match(_cache[9]);
          return m ? {
            key: m[1],
            pos: m[2],
            val: _cache[0] + m[3].trim() + _cache[1]
          } : { val: expr.trim() }
        };
        _brackets.hasRaw = function (src) {
          return _cache[10].test(src)
        };
        _brackets.array = function array(pair) {
          return pair ? _create(pair) : _cache
        };
        function _reset(pair) {
          if ((pair || (pair = DEFAULT)) !== _cache[8]) {
            _cache = _create(pair);
            _regex = pair === DEFAULT ? _loopback : _rewrite;
            _cache[9] = _regex(_pairs[9]);
            _cache[10] = _regex(_pairs[10])
          }
          cachedBrackets = pair
        }
        function _setSettings(o) {
          var b;
          o = o || {};
          b = o.brackets;
          Object.defineProperty(o, 'brackets', {
            set: _reset,
            get: function () {
              return cachedBrackets
            },
            enumerable: true
          });
          _settings = o;
          _reset(b)
        }
        Object.defineProperty(_brackets, 'settings', {
          set: _setSettings,
          get: function () {
            return _settings
          }
        });
        /* istanbul ignore next: in the browser riot is always in the scope */
        _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};
        _brackets.set = _reset;
        _brackets.R_STRINGS = R_STRINGS;
        _brackets.R_MLCOMMS = R_MLCOMMS;
        _brackets.S_QBLOCKS = S_QBLOCKS;
        return _brackets
      }();
      /**
 * @module tmpl
 *
 * tmpl          - Root function, returns the template value, render with data
 * tmpl.hasExpr  - Test the existence of a expression inside a string
 * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)
 */
      var tmpl = function () {
        var _cache = {};
        function _tmpl(str, data) {
          if (!str)
            return str;
          return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)
        }
        _tmpl.haveRaw = brackets.hasRaw;
        _tmpl.hasExpr = brackets.hasExpr;
        _tmpl.loopKeys = brackets.loopKeys;
        _tmpl.errorHandler = null;
        function _logErr(err, ctx) {
          if (_tmpl.errorHandler) {
            err.riotData = {
              tagName: ctx && ctx.root && ctx.root.tagName,
              _riot_id: ctx && ctx._riot_id
            };
            _tmpl.errorHandler(err)
          }
        }
        function _create(str) {
          var expr = _getTmpl(str);
          if (expr.slice(0, 11) !== 'try{return ')
            expr = 'return ' + expr;
          return new Function('E', expr + ';')
        }
        var RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'), RE_QBMARK = /\x01(\d+)~/g;
        function _getTmpl(str) {
          var qstr = [], expr, parts = brackets.split(str.replace(/\u2057/g, '"'), 1);
          if (parts.length > 2 || parts[0]) {
            var i, j, list = [];
            for (i = j = 0; i < parts.length; ++i) {
              expr = parts[i];
              if (expr && (expr = i & 1 ? _parseExpr(expr, 1, qstr) : '"' + expr.replace(/\\/g, '\\\\').replace(/\r\n?|\n/g, '\\n').replace(/"/g, '\\"') + '"'))
                list[j++] = expr
            }
            expr = j < 2 ? list[0] : '[' + list.join(',') + '].join("")'
          } else {
            expr = _parseExpr(parts[1], 0, qstr)
          }
          if (qstr[0])
            expr = expr.replace(RE_QBMARK, function (_, pos) {
              return qstr[pos].replace(/\r/g, '\\r').replace(/\n/g, '\\n')
            });
          return expr
        }
        var RE_BREND = {
            '(': /[()]/g,
            '[': /[[\]]/g,
            '{': /[{}]/g
          }, CS_IDENT = /^(?:(-?[_A-Za-z\xA0-\xFF][-\w\xA0-\xFF]*)|\x01(\d+)~):/;
        function _parseExpr(expr, asText, qstr) {
          if (expr[0] === '=')
            expr = expr.slice(1);
          expr = expr.replace(RE_QBLOCK, function (s, div) {
            return s.length > 2 && !div ? '' + (qstr.push(s) - 1) + '~' : s
          }).replace(/\s+/g, ' ').trim().replace(/\ ?([[\({},?\.:])\ ?/g, '$1');
          if (expr) {
            var list = [], cnt = 0, match;
            while (expr && (match = expr.match(CS_IDENT)) && !match.index) {
              var key, jsb, re = /,|([[{(])|$/g;
              expr = RegExp.rightContext;
              key = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\s+/g, ' ') : match[1];
              while (jsb = (match = re.exec(expr))[1])
                skipBraces(jsb, re);
              jsb = expr.slice(0, match.index);
              expr = RegExp.rightContext;
              list[cnt++] = _wrapExpr(jsb, 1, key)
            }
            expr = !cnt ? _wrapExpr(expr, asText) : cnt > 1 ? '[' + list.join(',') + '].join(" ").trim()' : list[0]
          }
          return expr;
          function skipBraces(ch, re) {
            var mm, lv = 1, ir = RE_BREND[ch];
            ir.lastIndex = re.lastIndex;
            while (mm = ir.exec(expr)) {
              if (mm[0] === ch)
                ++lv;
              else if (!--lv)
                break
            }
            re.lastIndex = lv ? expr.length : ir.lastIndex
          }
        }
        // istanbul ignore next: not both
        var JS_CONTEXT = '"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').', JS_VARNAME = /[,{][$\w]+:|(^ *|[^$\w\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\w]))([$_A-Za-z][$\w]*)/g, JS_NOPROPS = /^(?=(\.[$\w]+))\1(?:[^.[(]|$)/;
        function _wrapExpr(expr, asText, key) {
          var tb;
          expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {
            if (mvar) {
              pos = tb ? 0 : pos + match.length;
              if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {
                match = p + '("' + mvar + JS_CONTEXT + mvar;
                if (pos)
                  tb = (s = s[pos]) === '.' || s === '(' || s === '['
              } else if (pos) {
                tb = !JS_NOPROPS.test(s.slice(pos))
              }
            }
            return match
          });
          if (tb) {
            expr = 'try{return ' + expr + '}catch(e){E(e,this)}'
          }
          if (key) {
            expr = (tb ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')') + '?"' + key + '":""'
          } else if (asText) {
            expr = 'function(v){' + (tb ? expr.replace('return ', 'v=') : 'v=(' + expr + ')') + ';return v||v===0?v:""}.call(this)'
          }
          return expr
        }
        // istanbul ignore next: compatibility fix for beta versions
        _tmpl.parse = function (s) {
          return s
        };
        _tmpl.version = brackets.version = 'v2.3.21';
        return _tmpl
      }();
      /*
  lib/browser/tag/mkdom.js

  Includes hacks needed for the Internet Explorer version 9 and below
  See: http://kangax.github.io/compat-table/es5/#ie8
       http://codeplanet.io/dropping-ie8/
*/
      var mkdom = function _mkdom() {
        var reHasYield = /<yield\b/i, reYieldAll = /<yield\s*(?:\/>|>([\S\s]*?)<\/yield\s*>)/gi, reYieldSrc = /<yield\s+to=['"]([^'">]*)['"]\s*>([\S\s]*?)<\/yield\s*>/gi, reYieldDest = /<yield\s+from=['"]?([-\w]+)['"]?\s*(?:\/>|>([\S\s]*?)<\/yield\s*>)/gi;
        var rootEls = {
            tr: 'tbody',
            th: 'tr',
            td: 'tr',
            col: 'colgroup'
          }, tblTags = IE_VERSION && IE_VERSION < 10 ? SPECIAL_TAGS_REGEX : /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;
        /**
   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be
   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.
   *
   * @param   {string} templ  - The template coming from the custom tag definition
   * @param   {string} [html] - HTML content that comes from the DOM element where you
   *           will mount the tag, mostly the original tag in the page
   * @returns {HTMLElement} DOM element with _templ_ merged through `YIELD` with the _html_.
   */
        function _mkdom(templ, html) {
          var match = templ && templ.match(/^\s*<([-\w]+)/), tagName = match && match[1].toLowerCase(), el = mkEl('div');
          // replace all the yield tags with the tag inner html
          templ = replaceYield(templ, html);
          /* istanbul ignore next */
          if (tblTags.test(tagName))
            el = specialTags(el, templ, tagName);
          else
            el.innerHTML = templ;
          el.stub = true;
          return el
        }
        /*
    Creates the root element for table or select child elements:
    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup
  */
        function specialTags(el, templ, tagName) {
          var select = tagName[0] === 'o', parent = select ? 'select>' : 'table>';
          // trim() is important here, this ensures we don't have artifacts,
          // so we can check if we have only one element inside the parent
          el.innerHTML = '<' + parent + templ.trim() + '</' + parent;
          parent = el.firstChild;
          // returns the immediate parent if tr/th/td/col is the only element, if not
          // returns the whole tree, as this can include additional elements
          if (select) {
            parent.selectedIndex = -1  // for IE9, compatible w/current riot behavior
          } else {
            // avoids insertion of cointainer inside container (ex: tbody inside tbody)
            var tname = rootEls[tagName];
            if (tname && parent.childElementCount === 1)
              parent = $(tname, parent)
          }
          return parent
        }
        /*
    Replace the yield tag from any tag template with the innerHTML of the
    original tag in the page
  */
        function replaceYield(templ, html) {
          // do nothing if no yield
          if (!reHasYield.test(templ))
            return templ;
          // be careful with #1343 - string on the source having `$1`
          var src = {};
          html = html && html.replace(reYieldSrc, function (_, ref, text) {
            src[ref] = src[ref] || text;
            // preserve first definition
            return ''
          }).trim();
          return templ.replace(reYieldDest, function (_, ref, def) {
            // yield with from - to attrs
            return src[ref] || def || ''
          }).replace(reYieldAll, function (_, def) {
            // yield without any "from"
            return html || def || ''
          })
        }
        return _mkdom
      }();
      /**
 * Convert the item looped into an object used to extend the child tag properties
 * @param   { Object } expr - object containing the keys used to extend the children tags
 * @param   { * } key - value to assign to the new object returned
 * @param   { * } val - value containing the position of the item in the array
 * @returns { Object } - new object containing the values of the original item
 *
 * The variables 'key' and 'val' are arbitrary.
 * They depend on the collection type looped (Array, Object)
 * and on the expression used on the each tag
 *
 */
      function mkitem(expr, key, val) {
        var item = {};
        item[expr.key] = key;
        if (expr.pos)
          item[expr.pos] = val;
        return item
      }
      /**
 * Unmount the redundant tags
 * @param   { Array } items - array containing the current items to loop
 * @param   { Array } tags - array containing all the children tags
 */
      function unmountRedundant(items, tags) {
        var i = tags.length, j = items.length, t;
        while (i > j) {
          t = tags[--i];
          tags.splice(i, 1);
          t.unmount()
        }
      }
      /**
 * Move the nested custom tags in non custom loop tags
 * @param   { Object } child - non custom loop tag
 * @param   { Number } i - current position of the loop tag
 */
      function moveNestedTags(child, i) {
        Object.keys(child.tags).forEach(function (tagName) {
          var tag = child.tags[tagName];
          if (isArray(tag))
            each(tag, function (t) {
              moveChildTag(t, tagName, i)
            });
          else
            moveChildTag(tag, tagName, i)
        })
      }
      /**
 * Adds the elements for a virtual tag
 * @param { Tag } tag - the tag whose root's children will be inserted or appended
 * @param { Node } src - the node that will do the inserting or appending
 * @param { Tag } target - only if inserting, insert before this tag's first child
 */
      function addVirtual(tag, src, target) {
        var el = tag._root, sib;
        tag._virts = [];
        while (el) {
          sib = el.nextSibling;
          if (target)
            src.insertBefore(el, target._root);
          else
            src.appendChild(el);
          tag._virts.push(el);
          // hold for unmounting
          el = sib
        }
      }
      /**
 * Move virtual tag and all child nodes
 * @param { Tag } tag - first child reference used to start move
 * @param { Node } src  - the node that will do the inserting
 * @param { Tag } target - insert before this tag's first child
 * @param { Number } len - how many child nodes to move
 */
      function moveVirtual(tag, src, target, len) {
        var el = tag._root, sib, i = 0;
        for (; i < len; i++) {
          sib = el.nextSibling;
          src.insertBefore(el, target._root);
          el = sib
        }
      }
      /**
 * Manage tags having the 'each'
 * @param   { Object } dom - DOM node we need to loop
 * @param   { Tag } parent - parent tag instance where the dom node is contained
 * @param   { String } expr - string contained in the 'each' attribute
 */
      function _each(dom, parent, expr) {
        // remove the each property from the original tag
        remAttr(dom, 'each');
        var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'), tagName = getTagName(dom), impl = __tagImpl[tagName] || { tmpl: dom.outerHTML }, useRoot = SPECIAL_TAGS_REGEX.test(tagName), root = dom.parentNode, ref = document.createTextNode(''), child = getTag(dom), isOption = tagName.toLowerCase() === 'option',
          // the option tags must be treated differently
          tags = [], oldItems = [], hasKeys, isVirtual = dom.tagName == 'VIRTUAL';
        // parse the each expression
        expr = tmpl.loopKeys(expr);
        // insert a marked where the loop tags will be injected
        root.insertBefore(ref, dom);
        // clean template code
        parent.one('before-mount', function () {
          // remove the original DOM node
          dom.parentNode.removeChild(dom);
          if (root.stub)
            root = parent.root
        }).on('update', function () {
          // get the new items collection
          var items = tmpl(expr.val, parent),
            // create a fragment to hold the new DOM nodes to inject in the parent tag
            frag = document.createDocumentFragment();
          // object loop. any changes cause full redraw
          if (!isArray(items)) {
            hasKeys = items || false;
            items = hasKeys ? Object.keys(items).map(function (key) {
              return mkitem(expr, key, items[key])
            }) : []
          }
          // loop all the new items
          var i = 0, itemsLength = items.length;
          for (; i < itemsLength; i++) {
            // reorder only if the items are objects
            var item = items[i], _mustReorder = mustReorder && item instanceof Object && !hasKeys, oldPos = oldItems.indexOf(item), pos = ~oldPos && _mustReorder ? oldPos : i,
              // does a tag exist in this position?
              tag = tags[pos];
            item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;
            // new tag
            if (!_mustReorder && !tag  // with no-reorder we just update the old tags
|| _mustReorder && !~oldPos || !tag  // by default we always try to reorder the DOM elements
) {
              tag = new Tag(impl, {
                parent: parent,
                isLoop: true,
                hasImpl: !!__tagImpl[tagName],
                root: useRoot ? root : dom.cloneNode(),
                item: item
              }, dom.innerHTML);
              tag.mount();
              if (isVirtual)
                tag._root = tag.root.firstChild;
              // save reference for further moves or inserts
              // this tag must be appended
              if (i == tags.length || !tags[i]) {
                // fix 1581
                if (isVirtual)
                  addVirtual(tag, frag);
                else
                  frag.appendChild(tag.root)
              }  // this tag must be insert
              else {
                if (isVirtual)
                  addVirtual(tag, root, tags[i]);
                else
                  root.insertBefore(tag.root, tags[i].root);
                // #1374 some browsers reset selected here
                oldItems.splice(i, 0, item)
              }
              tags.splice(i, 0, tag);
              pos = i  // handled here so no move
            } else
              tag.update(item, true);
            // reorder the tag if it's not located in its previous position
            if (pos !== i && _mustReorder && tags[i]  // fix 1581 unable to reproduce it in a test!
) {
              // update the DOM
              if (isVirtual)
                moveVirtual(tag, root, tags[i], dom.childNodes.length);
              else
                root.insertBefore(tag.root, tags[i].root);
              // update the position attribute if it exists
              if (expr.pos)
                tag[expr.pos] = i;
              // move the old tag instance
              tags.splice(i, 0, tags.splice(pos, 1)[0]);
              // move the old item
              oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);
              // if the loop tags are not custom
              // we need to move all their custom tags into the right position
              if (!child && tag.tags)
                moveNestedTags(tag, i)
            }
            // cache the original item to use it in the events bound to this node
            // and its children
            tag._item = item;
            // cache the real parent tag internally
            defineProperty(tag, '_parent', parent)
          }
          // remove the redundant tags
          unmountRedundant(items, tags);
          // insert the new nodes
          if (isOption) {
            root.appendChild(frag);
            // #1374 <select> <option selected={true}> </select>
            if (root.length) {
              var si, op = root.options;
              root.selectedIndex = si = -1;
              for (i = 0; i < op.length; i++) {
                if (op[i].selected = op[i].__selected) {
                  if (si < 0)
                    root.selectedIndex = si = i
                }
              }
            }
          } else
            root.insertBefore(frag, ref);
          // set the 'tags' property of the parent tag
          // if child is 'undefined' it means that we don't need to set this property
          // for example:
          // we don't need store the `myTag.tags['div']` property if we are looping a div tag
          // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`
          if (child)
            parent.tags[tagName] = tags;
          // clone the items array
          oldItems = items.slice()
        })
      }
      /**
 * Object that will be used to inject and manage the css of every tag instance
 */
      var styleManager = function (_riot) {
        if (!window)
          return {
            // skip injection on the server
            add: function () {
            },
            inject: function () {
            }
          };
        var styleNode = function () {
          // create a new style element with the correct type
          var newNode = mkEl('style');
          setAttr(newNode, 'type', 'text/css');
          // replace any user node or insert the new one into the head
          var userNode = $('style[type=riot]');
          if (userNode) {
            if (userNode.id)
              newNode.id = userNode.id;
            userNode.parentNode.replaceChild(newNode, userNode)
          } else
            document.getElementsByTagName('head')[0].appendChild(newNode);
          return newNode
        }();
        // Create cache and shortcut to the correct property
        var cssTextProp = styleNode.styleSheet, stylesToInject = '';
        // Expose the style node in a non-modificable property
        Object.defineProperty(_riot, 'styleNode', {
          value: styleNode,
          writable: true
        });
        /**
   * Public api
   */
        return {
          /**
     * Save a tag style to be later injected into DOM
     * @param   { String } css [description]
     */
          add: function (css) {
            stylesToInject += css
          },
          /**
     * Inject all previously saved tag styles into DOM
     * innerHTML seems slow: http://jsperf.com/riot-insert-style
     */
          inject: function () {
            if (stylesToInject) {
              if (cssTextProp)
                cssTextProp.cssText += stylesToInject;
              else
                styleNode.innerHTML += stylesToInject;
              stylesToInject = ''
            }
          }
        }
      }(riot);
      function parseNamedElements(root, tag, childTags, forceParsingNamed) {
        walk(root, function (dom) {
          if (dom.nodeType == 1) {
            dom.isLoop = dom.isLoop || (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each')) ? 1 : 0;
            // custom child tag
            if (childTags) {
              var child = getTag(dom);
              if (child && !dom.isLoop)
                childTags.push(initChildTag(child, {
                  root: dom,
                  parent: tag
                }, dom.innerHTML, tag))
            }
            if (!dom.isLoop || forceParsingNamed)
              setNamed(dom, tag, [])
          }
        })
      }
      function parseExpressions(root, tag, expressions) {
        function addExpr(dom, val, extra) {
          if (tmpl.hasExpr(val)) {
            expressions.push(extend({
              dom: dom,
              expr: val
            }, extra))
          }
        }
        walk(root, function (dom) {
          var type = dom.nodeType, attr;
          // text node
          if (type == 3 && dom.parentNode.tagName != 'STYLE')
            addExpr(dom, dom.nodeValue);
          if (type != 1)
            return;
          /* element */
          // loop
          attr = getAttr(dom, 'each');
          if (attr) {
            _each(dom, tag, attr);
            return false
          }
          // attribute expressions
          each(dom.attributes, function (attr) {
            var name = attr.name, bool = name.split('__')[1];
            addExpr(dom, attr.value, {
              attr: bool || name,
              bool: bool
            });
            if (bool) {
              remAttr(dom, name);
              return false
            }
          });
          // skip custom tags
          if (getTag(dom))
            return false
        })
      }
      function Tag(impl, conf, innerHTML) {
        var self = riot.observable(this), opts = inherit(conf.opts) || {}, parent = conf.parent, isLoop = conf.isLoop, hasImpl = conf.hasImpl, item = cleanUpData(conf.item), expressions = [], childTags = [], root = conf.root, tagName = root.tagName.toLowerCase(), attr = {}, implAttr = {}, propsInSyncWithParent = [], dom;
        // only call unmount if we have a valid __tagImpl (has name property)
        if (impl.name && root._tag)
          root._tag.unmount(true);
        // not yet mounted
        this.isMounted = false;
        root.isLoop = isLoop;
        // keep a reference to the tag just created
        // so we will be able to mount this tag multiple times
        root._tag = this;
        // create a unique id to this tag
        // it could be handy to use it also to improve the virtual dom rendering speed
        defineProperty(this, '_riot_id', ++__uid);
        // base 1 allows test !t._riot_id
        extend(this, {
          parent: parent,
          root: root,
          opts: opts,
          tags: {}
        }, item);
        // grab attributes
        each(root.attributes, function (el) {
          var val = el.value;
          // remember attributes with expressions only
          if (tmpl.hasExpr(val))
            attr[el.name] = val
        });
        dom = mkdom(impl.tmpl, innerHTML);
        // options
        function updateOpts() {
          var ctx = hasImpl && isLoop ? self : parent || self;
          // update opts from current DOM attributes
          each(root.attributes, function (el) {
            var val = el.value;
            opts[toCamel(el.name)] = tmpl.hasExpr(val) ? tmpl(val, ctx) : val
          });
          // recover those with expressions
          each(Object.keys(attr), function (name) {
            opts[toCamel(name)] = tmpl(attr[name], ctx)
          })
        }
        function normalizeData(data) {
          for (var key in item) {
            if (typeof self[key] !== T_UNDEF && isWritable(self, key))
              self[key] = data[key]
          }
        }
        function inheritFromParent() {
          if (!self.parent || !isLoop)
            return;
          each(Object.keys(self.parent), function (k) {
            // some properties must be always in sync with the parent tag
            var mustSync = !contains(RESERVED_WORDS_BLACKLIST, k) && contains(propsInSyncWithParent, k);
            if (typeof self[k] === T_UNDEF || mustSync) {
              // track the property to keep in sync
              // so we can keep it updated
              if (!mustSync)
                propsInSyncWithParent.push(k);
              self[k] = self.parent[k]
            }
          })
        }
        /**
   * Update the tag expressions and options
   * @param   { * }  data - data we want to use to extend the tag properties
   * @param   { Boolean } isInherited - is this update coming from a parent tag?
   * @returns { self }
   */
        defineProperty(this, 'update', function (data, isInherited) {
          // make sure the data passed will not override
          // the component core methods
          data = cleanUpData(data);
          // inherit properties from the parent
          inheritFromParent();
          // normalize the tag properties in case an item object was initially passed
          if (data && isObject(item)) {
            normalizeData(data);
            item = data
          }
          extend(self, data);
          updateOpts();
          self.trigger('update', data);
          update(expressions, self);
          // the updated event will be triggered
          // once the DOM will be ready and all the re-flows are completed
          // this is useful if you want to get the "real" root properties
          // 4 ex: root.offsetWidth ...
          if (isInherited && self.parent)
            // closes #1599
            self.parent.one('updated', function () {
              self.trigger('updated')
            });
          else
            rAF(function () {
              self.trigger('updated')
            });
          return this
        });
        defineProperty(this, 'mixin', function () {
          each(arguments, function (mix) {
            var instance;
            mix = typeof mix === T_STRING ? riot.mixin(mix) : mix;
            // check if the mixin is a function
            if (isFunction(mix)) {
              // create the new mixin instance
              instance = new mix;
              // save the prototype to loop it afterwards
              mix = mix.prototype
            } else
              instance = mix;
            // loop the keys in the function prototype or the all object keys
            each(Object.getOwnPropertyNames(mix), function (key) {
              // bind methods to self
              if (key != 'init')
                self[key] = isFunction(instance[key]) ? instance[key].bind(self) : instance[key]
            });
            // init method will be called automatically
            if (instance.init)
              instance.init.bind(self)()
          });
          return this
        });
        defineProperty(this, 'mount', function () {
          updateOpts();
          // add global mixin
          var globalMixin = riot.mixin(GLOBAL_MIXIN);
          if (globalMixin)
            self.mixin(globalMixin);
          // initialiation
          if (impl.fn)
            impl.fn.call(self, opts);
          // parse layout after init. fn may calculate args for nested custom tags
          parseExpressions(dom, self, expressions);
          // mount the child tags
          toggle(true);
          // update the root adding custom attributes coming from the compiler
          // it fixes also #1087
          if (impl.attrs)
            walkAttributes(impl.attrs, function (k, v) {
              setAttr(root, k, v)
            });
          if (impl.attrs || hasImpl)
            parseExpressions(self.root, self, expressions);
          if (!self.parent || isLoop)
            self.update(item);
          // internal use only, fixes #403
          self.trigger('before-mount');
          if (isLoop && !hasImpl) {
            // update the root attribute for the looped elements
            root = dom.firstChild
          } else {
            while (dom.firstChild)
              root.appendChild(dom.firstChild);
            if (root.stub)
              root = parent.root
          }
          defineProperty(self, 'root', root);
          // parse the named dom nodes in the looped child
          // adding them to the parent as well
          if (isLoop)
            parseNamedElements(self.root, self.parent, null, true);
          // if it's not a child tag we can trigger its mount event
          if (!self.parent || self.parent.isMounted) {
            self.isMounted = true;
            self.trigger('mount')
          }  // otherwise we need to wait that the parent event gets triggered
          else
            self.parent.one('mount', function () {
              // avoid to trigger the `mount` event for the tags
              // not visible included in an if statement
              if (!isInStub(self.root)) {
                self.parent.isMounted = self.isMounted = true;
                self.trigger('mount')
              }
            })
        });
        defineProperty(this, 'unmount', function (keepRootTag) {
          var el = root, p = el.parentNode, ptag, tagIndex = __virtualDom.indexOf(self);
          self.trigger('before-unmount');
          // remove this tag instance from the global virtualDom variable
          if (~tagIndex)
            __virtualDom.splice(tagIndex, 1);
          if (this._virts) {
            each(this._virts, function (v) {
              if (v.parentNode)
                v.parentNode.removeChild(v)
            })
          }
          if (p) {
            if (parent) {
              ptag = getImmediateCustomParentTag(parent);
              // remove this tag from the parent tags object
              // if there are multiple nested tags with same name..
              // remove this element form the array
              if (isArray(ptag.tags[tagName]))
                each(ptag.tags[tagName], function (tag, i) {
                  if (tag._riot_id == self._riot_id)
                    ptag.tags[tagName].splice(i, 1)
                });
              else
                // otherwise just delete the tag instance
                ptag.tags[tagName] = undefined
            } else
              while (el.firstChild)
                el.removeChild(el.firstChild);
            if (!keepRootTag)
              p.removeChild(el);
            else
              // the riot-tag attribute isn't needed anymore, remove it
              remAttr(p, 'riot-tag')
          }
          self.trigger('unmount');
          toggle();
          self.off('*');
          self.isMounted = false;
          delete root._tag
        });
        // proxy function to bind updates
        // dispatched from a parent tag
        function onChildUpdate(data) {
          self.update(data, true)
        }
        function toggle(isMount) {
          // mount/unmount children
          each(childTags, function (child) {
            child[isMount ? 'mount' : 'unmount']()
          });
          // listen/unlisten parent (events flow one way from parent to children)
          if (!parent)
            return;
          var evt = isMount ? 'on' : 'off';
          // the loop tags will be always in sync with the parent automatically
          if (isLoop)
            parent[evt]('unmount', self.unmount);
          else {
            parent[evt]('update', onChildUpdate)[evt]('unmount', self.unmount)
          }
        }
        // named elements available for fn
        parseNamedElements(dom, this, childTags)
      }
      /**
 * Attach an event to a DOM node
 * @param { String } name - event name
 * @param { Function } handler - event callback
 * @param { Object } dom - dom node
 * @param { Tag } tag - tag instance
 */
      function setEventHandler(name, handler, dom, tag) {
        dom[name] = function (e) {
          var ptag = tag._parent, item = tag._item, el;
          if (!item)
            while (ptag && !item) {
              item = ptag._item;
              ptag = ptag._parent
            }
          // cross browser event fix
          e = e || window.event;
          // override the event properties
          if (isWritable(e, 'currentTarget'))
            e.currentTarget = dom;
          if (isWritable(e, 'target'))
            e.target = e.srcElement;
          if (isWritable(e, 'which'))
            e.which = e.charCode || e.keyCode;
          e.item = item;
          // prevent default behaviour (by default)
          if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {
            if (e.preventDefault)
              e.preventDefault();
            e.returnValue = false
          }
          if (!e.preventUpdate) {
            el = item ? getImmediateCustomParentTag(ptag) : tag;
            el.update()
          }
        }
      }
      /**
 * Insert a DOM node replacing another one (used by if- attribute)
 * @param   { Object } root - parent node
 * @param   { Object } node - node replaced
 * @param   { Object } before - node added
 */
      function insertTo(root, node, before) {
        if (!root)
          return;
        root.insertBefore(before, node);
        root.removeChild(node)
      }
      /**
 * Update the expressions in a Tag instance
 * @param   { Array } expressions - expression that must be re evaluated
 * @param   { Tag } tag - tag instance
 */
      function update(expressions, tag) {
        each(expressions, function (expr, i) {
          var dom = expr.dom, attrName = expr.attr, value = tmpl(expr.expr, tag), parent = expr.dom.parentNode;
          if (expr.bool) {
            value = !!value;
            if (attrName === 'selected')
              dom.__selected = value  // #1374
          } else if (value == null)
            value = '';
          // #1638: regression of #1612, update the dom only if the value of the
          // expression was changed
          if (expr.value === value) {
            return
          }
          expr.value = value;
          // textarea and text nodes has no attribute name
          if (!attrName) {
            // about #815 w/o replace: the browser converts the value to a string,
            // the comparison by "==" does too, but not in the server
            value += '';
            // test for parent avoids error with invalid assignment to nodeValue
            if (parent) {
              if (parent.tagName === 'TEXTAREA') {
                parent.value = value;
                // #1113
                if (!IE_VERSION)
                  dom.nodeValue = value  // #1625 IE throws here, nodeValue
              }  // will be available on 'updated'
              else
                dom.nodeValue = value
            }
            return
          }
          // ~~#1612: look for changes in dom.value when updating the value~~
          if (attrName === 'value') {
            dom.value = value;
            return
          }
          // remove original attribute
          remAttr(dom, attrName);
          // event handler
          if (isFunction(value)) {
            setEventHandler(attrName, value, dom, tag)  // if- conditional
          } else if (attrName == 'if') {
            var stub = expr.stub, add = function () {
                insertTo(stub.parentNode, stub, dom)
              }, remove = function () {
                insertTo(dom.parentNode, dom, stub)
              };
            // add to DOM
            if (value) {
              if (stub) {
                add();
                dom.inStub = false;
                // avoid to trigger the mount event if the tags is not visible yet
                // maybe we can optimize this avoiding to mount the tag at all
                if (!isInStub(dom)) {
                  walk(dom, function (el) {
                    if (el._tag && !el._tag.isMounted)
                      el._tag.isMounted = !!el._tag.trigger('mount')
                  })
                }
              }  // remove from DOM
            } else {
              stub = expr.stub = stub || document.createTextNode('');
              // if the parentNode is defined we can easily replace the tag
              if (dom.parentNode)
                remove()  // otherwise we need to wait the updated event
;
              else
                (tag.parent || tag).one('updated', remove);
              dom.inStub = true
            }  // show / hide
          } else if (attrName === 'show') {
            dom.style.display = value ? '' : 'none'
          } else if (attrName === 'hide') {
            dom.style.display = value ? 'none' : ''
          } else if (expr.bool) {
            dom[attrName] = value;
            if (value)
              setAttr(dom, attrName, attrName)
          } else if (value === 0 || value && typeof value !== T_OBJECT) {
            // <img src="{ expr }">
            if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {
              attrName = attrName.slice(RIOT_PREFIX.length)
            }
            setAttr(dom, attrName, value)
          }
        })
      }
      /**
 * Specialized function for looping an array-like collection with `each={}`
 * @param   { Array } els - collection of items
 * @param   {Function} fn - callback function
 * @returns { Array } the array looped
 */
      function each(els, fn) {
        var len = els ? els.length : 0;
        for (var i = 0, el; i < len; i++) {
          el = els[i];
          // return false -> current item was removed by fn during the loop
          if (el != null && fn(el, i) === false)
            i--
        }
        return els
      }
      /**
 * Detect if the argument passed is a function
 * @param   { * } v - whatever you want to pass to this function
 * @returns { Boolean } -
 */
      function isFunction(v) {
        return typeof v === T_FUNCTION || false  // avoid IE problems
      }
      /**
 * Detect if the argument passed is an object, exclude null.
 * NOTE: Use isObject(x) && !isArray(x) to excludes arrays.
 * @param   { * } v - whatever you want to pass to this function
 * @returns { Boolean } -
 */
      function isObject(v) {
        return v && typeof v === T_OBJECT  // typeof null is 'object'
      }
      /**
 * Remove any DOM attribute from a node
 * @param   { Object } dom - DOM node we want to update
 * @param   { String } name - name of the property we want to remove
 */
      function remAttr(dom, name) {
        dom.removeAttribute(name)
      }
      /**
 * Convert a string containing dashes to camel case
 * @param   { String } string - input string
 * @returns { String } my-string -> myString
 */
      function toCamel(string) {
        return string.replace(/-(\w)/g, function (_, c) {
          return c.toUpperCase()
        })
      }
      /**
 * Get the value of any DOM attribute on a node
 * @param   { Object } dom - DOM node we want to parse
 * @param   { String } name - name of the attribute we want to get
 * @returns { String | undefined } name of the node attribute whether it exists
 */
      function getAttr(dom, name) {
        return dom.getAttribute(name)
      }
      /**
 * Set any DOM attribute
 * @param { Object } dom - DOM node we want to update
 * @param { String } name - name of the property we want to set
 * @param { String } val - value of the property we want to set
 */
      function setAttr(dom, name, val) {
        dom.setAttribute(name, val)
      }
      /**
 * Detect the tag implementation by a DOM node
 * @param   { Object } dom - DOM node we need to parse to get its tag implementation
 * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)
 */
      function getTag(dom) {
        return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG_IS) || getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]
      }
      /**
 * Add a child tag to its parent into the `tags` object
 * @param   { Object } tag - child tag instance
 * @param   { String } tagName - key where the new tag will be stored
 * @param   { Object } parent - tag instance where the new child tag will be included
 */
      function addChildTag(tag, tagName, parent) {
        var cachedTag = parent.tags[tagName];
        // if there are multiple children tags having the same name
        if (cachedTag) {
          // if the parent tags property is not yet an array
          // create it adding the first cached tag
          if (!isArray(cachedTag))
            // don't add the same tag twice
            if (cachedTag !== tag)
              parent.tags[tagName] = [cachedTag];
          // add the new nested tag to the array
          if (!contains(parent.tags[tagName], tag))
            parent.tags[tagName].push(tag)
        } else {
          parent.tags[tagName] = tag
        }
      }
      /**
 * Move the position of a custom tag in its parent tag
 * @param   { Object } tag - child tag instance
 * @param   { String } tagName - key where the tag was stored
 * @param   { Number } newPos - index where the new tag will be stored
 */
      function moveChildTag(tag, tagName, newPos) {
        var parent = tag.parent, tags;
        // no parent no move
        if (!parent)
          return;
        tags = parent.tags[tagName];
        if (isArray(tags))
          tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0]);
        else
          addChildTag(tag, tagName, parent)
      }
      /**
 * Create a new child tag including it correctly into its parent
 * @param   { Object } child - child tag implementation
 * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted
 * @param   { String } innerHTML - inner html of the child node
 * @param   { Object } parent - instance of the parent tag including the child custom tag
 * @returns { Object } instance of the new child tag just created
 */
      function initChildTag(child, opts, innerHTML, parent) {
        var tag = new Tag(child, opts, innerHTML), tagName = getTagName(opts.root), ptag = getImmediateCustomParentTag(parent);
        // fix for the parent attribute in the looped elements
        tag.parent = ptag;
        // store the real parent tag
        // in some cases this could be different from the custom parent tag
        // for example in nested loops
        tag._parent = parent;
        // add this tag to the custom parent tag
        addChildTag(tag, tagName, ptag);
        // and also to the real parent tag
        if (ptag !== parent)
          addChildTag(tag, tagName, parent);
        // empty the child node once we got its template
        // to avoid that its children get compiled multiple times
        opts.root.innerHTML = '';
        return tag
      }
      /**
 * Loop backward all the parents tree to detect the first custom parent tag
 * @param   { Object } tag - a Tag instance
 * @returns { Object } the instance of the first custom parent tag found
 */
      function getImmediateCustomParentTag(tag) {
        var ptag = tag;
        while (!getTag(ptag.root)) {
          if (!ptag.parent)
            break;
          ptag = ptag.parent
        }
        return ptag
      }
      /**
 * Helper function to set an immutable property
 * @param   { Object } el - object where the new property will be set
 * @param   { String } key - object key where the new property will be stored
 * @param   { * } value - value of the new property
* @param   { Object } options - set the propery overriding the default options
 * @returns { Object } - the initial object
 */
      function defineProperty(el, key, value, options) {
        Object.defineProperty(el, key, extend({
          value: value,
          enumerable: false,
          writable: false,
          configurable: false
        }, options));
        return el
      }
      /**
 * Get the tag name of any DOM node
 * @param   { Object } dom - DOM node we want to parse
 * @returns { String } name to identify this dom node in riot
 */
      function getTagName(dom) {
        var child = getTag(dom), namedTag = getAttr(dom, 'name'), tagName = namedTag && !tmpl.hasExpr(namedTag) ? namedTag : child ? child.name : dom.tagName.toLowerCase();
        return tagName
      }
      /**
 * Extend any object with other properties
 * @param   { Object } src - source object
 * @returns { Object } the resulting extended object
 *
 * var obj = { foo: 'baz' }
 * extend(obj, {bar: 'bar', foo: 'bar'})
 * console.log(obj) => {bar: 'bar', foo: 'bar'}
 *
 */
      function extend(src) {
        var obj, args = arguments;
        for (var i = 1; i < args.length; ++i) {
          if (obj = args[i]) {
            for (var key in obj) {
              // check if this property of the source object could be overridden
              if (isWritable(src, key))
                src[key] = obj[key]
            }
          }
        }
        return src
      }
      /**
 * Check whether an array contains an item
 * @param   { Array } arr - target array
 * @param   { * } item - item to test
 * @returns { Boolean } Does 'arr' contain 'item'?
 */
      function contains(arr, item) {
        return ~arr.indexOf(item)
      }
      /**
 * Check whether an object is a kind of array
 * @param   { * } a - anything
 * @returns {Boolean} is 'a' an array?
 */
      function isArray(a) {
        return Array.isArray(a) || a instanceof Array
      }
      /**
 * Detect whether a property of an object could be overridden
 * @param   { Object }  obj - source object
 * @param   { String }  key - object property
 * @returns { Boolean } is this property writable?
 */
      function isWritable(obj, key) {
        var props = Object.getOwnPropertyDescriptor(obj, key);
        return typeof obj[key] === T_UNDEF || props && props.writable
      }
      /**
 * With this function we avoid that the internal Tag methods get overridden
 * @param   { Object } data - options we want to use to extend the tag instance
 * @returns { Object } clean object without containing the riot internal reserved words
 */
      function cleanUpData(data) {
        if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION))
          return data;
        var o = {};
        for (var key in data) {
          if (!contains(RESERVED_WORDS_BLACKLIST, key))
            o[key] = data[key]
        }
        return o
      }
      /**
 * Walk down recursively all the children tags starting dom node
 * @param   { Object }   dom - starting node where we will start the recursion
 * @param   { Function } fn - callback to transform the child node just found
 */
      function walk(dom, fn) {
        if (dom) {
          // stop the recursion
          if (fn(dom) === false)
            return;
          else {
            dom = dom.firstChild;
            while (dom) {
              walk(dom, fn);
              dom = dom.nextSibling
            }
          }
        }
      }
      /**
 * Minimize risk: only zero or one _space_ between attr & value
 * @param   { String }   html - html string we want to parse
 * @param   { Function } fn - callback function to apply on any attribute found
 */
      function walkAttributes(html, fn) {
        var m, re = /([-\w]+) ?= ?(?:"([^"]*)|'([^']*)|({[^}]*}))/g;
        while (m = re.exec(html)) {
          fn(m[1].toLowerCase(), m[2] || m[3] || m[4])
        }
      }
      /**
 * Check whether a DOM node is in stub mode, useful for the riot 'if' directive
 * @param   { Object }  dom - DOM node we want to parse
 * @returns { Boolean } -
 */
      function isInStub(dom) {
        while (dom) {
          if (dom.inStub)
            return true;
          dom = dom.parentNode
        }
        return false
      }
      /**
 * Create a generic DOM node
 * @param   { String } name - name of the DOM node we want to create
 * @returns { Object } DOM node just created
 */
      function mkEl(name) {
        return document.createElement(name)
      }
      /**
 * Shorter and fast way to select multiple nodes in the DOM
 * @param   { String } selector - DOM selector
 * @param   { Object } ctx - DOM node where the targets of our search will is located
 * @returns { Object } dom nodes found
 */
      function $$(selector, ctx) {
        return (ctx || document).querySelectorAll(selector)
      }
      /**
 * Shorter and fast way to select a single node in the DOM
 * @param   { String } selector - unique dom selector
 * @param   { Object } ctx - DOM node where the target of our search will is located
 * @returns { Object } dom node found
 */
      function $(selector, ctx) {
        return (ctx || document).querySelector(selector)
      }
      /**
 * Simple object prototypal inheritance
 * @param   { Object } parent - parent object
 * @returns { Object } child instance
 */
      function inherit(parent) {
        function Child() {
        }
        Child.prototype = parent;
        return new Child
      }
      /**
 * Get the name property needed to identify a DOM node in riot
 * @param   { Object } dom - DOM node we need to parse
 * @returns { String | undefined } give us back a string to identify this dom node
 */
      function getNamedKey(dom) {
        return getAttr(dom, 'id') || getAttr(dom, 'name')
      }
      /**
 * Set the named properties of a tag element
 * @param { Object } dom - DOM node we need to parse
 * @param { Object } parent - tag instance where the named dom element will be eventually added
 * @param { Array } keys - list of all the tag instance properties
 */
      function setNamed(dom, parent, keys) {
        // get the key value we want to add to the tag instance
        var key = getNamedKey(dom), isArr,
          // add the node detected to a tag instance using the named property
          add = function (value) {
            // avoid to override the tag properties already set
            if (contains(keys, key))
              return;
            // check whether this value is an array
            isArr = isArray(value);
            // if the key was never set
            if (!value)
              // set it once on the tag instance
              parent[key] = dom  // if it was an array and not yet set
;
            else if (!isArr || isArr && !contains(value, dom)) {
              // add the dom node into the array
              if (isArr)
                value.push(dom);
              else
                parent[key] = [
                  value,
                  dom
                ]
            }
          };
        // skip the elements with no named properties
        if (!key)
          return;
        // check whether this key has been already evaluated
        if (tmpl.hasExpr(key))
          // wait the first updated event only once
          parent.one('mount', function () {
            key = getNamedKey(dom);
            add(parent[key])
          });
        else
          add(parent[key])
      }
      /**
 * Faster String startsWith alternative
 * @param   { String } src - source string
 * @param   { String } str - test string
 * @returns { Boolean } -
 */
      function startsWith(src, str) {
        return src.slice(0, str.length) === str
      }
      /**
 * requestAnimationFrame function
 * Adapted from https://gist.github.com/paulirish/1579671, license MIT
 */
      var rAF = function (w) {
        var raf = w.requestAnimationFrame || w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame;
        if (!raf || /iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent)) {
          // buggy iOS6
          var lastTime = 0;
          raf = function (cb) {
            var nowtime = Date.now(), timeout = Math.max(16 - (nowtime - lastTime), 0);
            setTimeout(function () {
              cb(lastTime = nowtime + timeout)
            }, timeout)
          }
        }
        return raf
      }(window || {});
      /**
 * Mount a tag creating new Tag instance
 * @param   { Object } root - dom node where the tag will be mounted
 * @param   { String } tagName - name of the riot tag we want to mount
 * @param   { Object } opts - options to pass to the Tag instance
 * @returns { Tag } a new Tag instance
 */
      function mountTo(root, tagName, opts) {
        var tag = __tagImpl[tagName],
          // cache the inner HTML to fix #855
          innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;
        // clear the inner html
        root.innerHTML = '';
        if (tag && root)
          tag = new Tag(tag, {
            root: root,
            opts: opts
          }, innerHTML);
        if (tag && tag.mount) {
          tag.mount();
          // add this tag to the virtualDom variable
          if (!contains(__virtualDom, tag))
            __virtualDom.push(tag)
        }
        return tag
      }
      /**
 * Riot public api
 */
      // share methods for other riot parts, e.g. compiler
      riot.util = {
        brackets: brackets,
        tmpl: tmpl
      };
      /**
 * Create a mixin that could be globally shared across all the tags
 */
      riot.mixin = function () {
        var mixins = {};
        /**
   * Create/Return a mixin by its name
   * @param   { String } name - mixin name (global mixin if missing)
   * @param   { Object } mixin - mixin logic
   * @returns { Object } the mixin logic
   */
        return function (name, mixin) {
          if (isObject(name)) {
            mixin = name;
            mixins[GLOBAL_MIXIN] = extend(mixins[GLOBAL_MIXIN] || {}, mixin);
            return
          }
          if (!mixin)
            return mixins[name];
          mixins[name] = mixin
        }
      }();
      /**
 * Create a new riot tag implementation
 * @param   { String }   name - name/id of the new riot tag
 * @param   { String }   html - tag template
 * @param   { String }   css - custom tag css
 * @param   { String }   attrs - root tag attributes
 * @param   { Function } fn - user function
 * @returns { String } name/id of the tag just created
 */
      riot.tag = function (name, html, css, attrs, fn) {
        if (isFunction(attrs)) {
          fn = attrs;
          if (/^[\w\-]+\s?=/.test(css)) {
            attrs = css;
            css = ''
          } else
            attrs = ''
        }
        if (css) {
          if (isFunction(css))
            fn = css;
          else
            styleManager.add(css)
        }
        name = name.toLowerCase();
        __tagImpl[name] = {
          name: name,
          tmpl: html,
          attrs: attrs,
          fn: fn
        };
        return name
      };
      /**
 * Create a new riot tag implementation (for use by the compiler)
 * @param   { String }   name - name/id of the new riot tag
 * @param   { String }   html - tag template
 * @param   { String }   css - custom tag css
 * @param   { String }   attrs - root tag attributes
 * @param   { Function } fn - user function
 * @returns { String } name/id of the tag just created
 */
      riot.tag2 = function (name, html, css, attrs, fn) {
        if (css)
          styleManager.add(css);
        //if (bpair) riot.settings.brackets = bpair
        __tagImpl[name] = {
          name: name,
          tmpl: html,
          attrs: attrs,
          fn: fn
        };
        return name
      };
      /**
 * Mount a tag using a specific tag implementation
 * @param   { String } selector - tag DOM selector
 * @param   { String } tagName - tag implementation name
 * @param   { Object } opts - tag logic
 * @returns { Array } new tags instances
 */
      riot.mount = function (selector, tagName, opts) {
        var els, allTags, tags = [];
        // helper functions
        function addRiotTags(arr) {
          var list = '';
          each(arr, function (e) {
            if (!/[^-\w]/.test(e)) {
              e = e.trim().toLowerCase();
              list += ',[' + RIOT_TAG_IS + '="' + e + '"],[' + RIOT_TAG + '="' + e + '"]'
            }
          });
          return list
        }
        function selectAllTags() {
          var keys = Object.keys(__tagImpl);
          return keys + addRiotTags(keys)
        }
        function pushTags(root) {
          if (root.tagName) {
            var riotTag = getAttr(root, RIOT_TAG_IS) || getAttr(root, RIOT_TAG);
            // have tagName? force riot-tag to be the same
            if (tagName && riotTag !== tagName) {
              riotTag = tagName;
              setAttr(root, RIOT_TAG_IS, tagName)
            }
            var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);
            if (tag)
              tags.push(tag)
          } else if (root.length) {
            each(root, pushTags)  // assume nodeList
          }
        }
        // ----- mount code -----
        // inject styles into DOM
        styleManager.inject();
        if (isObject(tagName)) {
          opts = tagName;
          tagName = 0
        }
        // crawl the DOM to find the tag
        if (typeof selector === T_STRING) {
          if (selector === '*')
            // select all the tags registered
            // and also the tags found with the riot-tag attribute set
            selector = allTags = selectAllTags();
          else
            // or just the ones named like the selector
            selector += addRiotTags(selector.split(/, */));
          // make sure to pass always a selector
          // to the querySelectorAll function
          els = selector ? $$(selector) : []
        } else
          // probably you have passed already a tag or a NodeList
          els = selector;
        // select all the registered and mount them inside their root elements
        if (tagName === '*') {
          // get all custom tags
          tagName = allTags || selectAllTags();
          // if the root els it's just a single tag
          if (els.tagName)
            els = $$(tagName, els);
          else {
            // select all the children for all the different root elements
            var nodeList = [];
            each(els, function (_el) {
              nodeList.push($$(tagName, _el))
            });
            els = nodeList
          }
          // get rid of the tagName
          tagName = 0
        }
        pushTags(els);
        return tags
      };
      /**
 * Update all the tags instances created
 * @returns { Array } all the tags instances
 */
      riot.update = function () {
        return each(__virtualDom, function (tag) {
          tag.update()
        })
      };
      /**
 * Export the Tag constructor
 */
      riot.Tag = Tag;
      // support CommonJS, AMD & browser
      /* istanbul ignore next */
      if (typeof exports === T_OBJECT)
        module.exports = riot;
      else if (typeof define === T_FUNCTION && typeof define.amd !== T_UNDEF)
        define(function () {
          return riot
        });
      else
        window.riot = riot
    }(typeof window != 'undefined' ? window : void 0))
  });
  // source: src/module.coffee
  require.define('./module', function (module, exports, __dirname, __filename, process) {
    var Promise, Xhr;
    Promise = require('broken/lib');
    Xhr = require('xhr-promise-es6/lib');
    Xhr.Promise = Promise;
    require.urlFor = function (file) {
      return '/example/fixtures/' + file
    };
    module.exports = {
      moduleDefinitions: [],
      modulesRequired: [],
      modules: {},
      init: function (modulesUrl) {
        var opts;
        this.modulesUrl = modulesUrl;
        opts = {
          url: this.modulesUrl,
          method: 'GET'
        };
        return new Xhr().send(opts).then(function (_this) {
          return function (res) {
            _this.moduleDefinitions = res.responseText;
            return _this.moduleDefinitions
          }
        }(this))['catch'](function (res) {
          return console.log('ERROR:', res)
        })
      },
      load: function (modulesRequired, defaultModule) {
        this.modulesRequired = modulesRequired;
        this.defaultModule = defaultModule;
        return new Promise(function (_this) {
          return function (resolve, reject) {
            var fn, i, len, module, moduleRequired, modules, ref, timeoutId, waits;
            timeoutId = setTimeout(function () {
              return reject(new Error('Loading Timed Out'))
            }, 10000);
            waits = 0;
            _this.modules = modules = {};
            ref = _this.modulesRequired;
            fn = function (modules) {
              var m;
              m = {};
              m.definition = module;
              require(module.name + '-v' + module.version + '/bundle.js', function (js) {
                m.js = js;
                waits--;
                clearTimeout(timeoutId);
                modules[js.name] = js;
                if (waits === 0) {
                  return resolve(modules)
                }
              });
              return m.css = module.name + '-v' + module.version + '/bundle.css'
            };
            for (i = 0, len = ref.length; i < len; i++) {
              moduleRequired = ref[i];
              module = _this._getModule(moduleRequired);
              waits++;
              fn(modules)
            }
            if (waits === 0) {
              return p.resolve(_this.modules)
            }
          }
        }(this))
      },
      _getModule: function (moduleName) {
        var i, len, module, ref;
        ref = this.moduleDefinitions;
        for (i = 0, len = ref.length; i < len; i++) {
          module = ref[i];
          if (moduleName === module.name) {
            return module
          }
        }
      }
    }
  });
  // source: node_modules/xhr-promise-es6/lib/index.js
  require.define('xhr-promise-es6/lib', function (module, exports, __dirname, __filename, process) {
    /*
 * Copyright 2015 Scott Brady
 * MIT License
 * https://github.com/scottbrady/xhr-promise/blob/master/LICENSE
 */
    var ParseHeaders, XMLHttpRequestPromise, objectAssign;
    ParseHeaders = require('parse-headers/parse-headers');
    objectAssign = require('object-assign');
    /*
 * Module to wrap an XMLHttpRequest in a promise.
 */
    module.exports = XMLHttpRequestPromise = function () {
      function XMLHttpRequestPromise() {
      }
      XMLHttpRequestPromise.DEFAULT_CONTENT_TYPE = 'application/x-www-form-urlencoded; charset=UTF-8';
      XMLHttpRequestPromise.Promise = global.Promise;
      /*
   * XMLHttpRequestPromise.send(options) -> Promise
   * - options (Object): URL, method, data, etc.
   *
   * Create the XHR object and wire up event handlers to use a promise.
   */
      XMLHttpRequestPromise.prototype.send = function (options) {
        var defaults;
        if (options == null) {
          options = {}
        }
        defaults = {
          method: 'GET',
          data: null,
          headers: {},
          async: true,
          username: null,
          password: null
        };
        options = objectAssign({}, defaults, options);
        return new this.constructor.Promise(function (_this) {
          return function (resolve, reject) {
            var e, header, ref, value, xhr;
            if (!XMLHttpRequest) {
              _this._handleError('browser', reject, null, "browser doesn't support XMLHttpRequest");
              return
            }
            if (typeof options.url !== 'string' || options.url.length === 0) {
              _this._handleError('url', reject, null, 'URL is a required parameter');
              return
            }
            _this._xhr = xhr = new XMLHttpRequest;
            xhr.onload = function () {
              var responseText;
              _this._detachWindowUnload();
              try {
                responseText = _this._getResponseText()
              } catch (_error) {
                _this._handleError('parse', reject, null, 'invalid JSON response');
                return
              }
              return resolve({
                url: _this._getResponseUrl(),
                status: xhr.status,
                statusText: xhr.statusText,
                responseText: responseText,
                headers: _this._getHeaders(),
                xhr: xhr
              })
            };
            xhr.onerror = function () {
              return _this._handleError('error', reject)
            };
            xhr.ontimeout = function () {
              return _this._handleError('timeout', reject)
            };
            xhr.onabort = function () {
              return _this._handleError('abort', reject)
            };
            _this._attachWindowUnload();
            xhr.open(options.method, options.url, options.async, options.username, options.password);
            if (options.data != null && !options.headers['Content-Type']) {
              options.headers['Content-Type'] = _this.constructor.DEFAULT_CONTENT_TYPE
            }
            ref = options.headers;
            for (header in ref) {
              value = ref[header];
              xhr.setRequestHeader(header, value)
            }
            try {
              return xhr.send(options.data)
            } catch (_error) {
              e = _error;
              return _this._handleError('send', reject, null, e.toString())
            }
          }
        }(this))
      };
      /*
   * XMLHttpRequestPromise.getXHR() -> XMLHttpRequest
   */
      XMLHttpRequestPromise.prototype.getXHR = function () {
        return this._xhr
      };
      /*
   * XMLHttpRequestPromise._attachWindowUnload()
   *
   * Fix for IE 9 and IE 10
   * Internet Explorer freezes when you close a webpage during an XHR request
   * https://support.microsoft.com/kb/2856746
   *
   */
      XMLHttpRequestPromise.prototype._attachWindowUnload = function () {
        this._unloadHandler = this._handleWindowUnload.bind(this);
        if (window.attachEvent) {
          return window.attachEvent('onunload', this._unloadHandler)
        }
      };
      /*
   * XMLHttpRequestPromise._detachWindowUnload()
   */
      XMLHttpRequestPromise.prototype._detachWindowUnload = function () {
        if (window.detachEvent) {
          return window.detachEvent('onunload', this._unloadHandler)
        }
      };
      /*
   * XMLHttpRequestPromise._getHeaders() -> Object
   */
      XMLHttpRequestPromise.prototype._getHeaders = function () {
        return ParseHeaders(this._xhr.getAllResponseHeaders())
      };
      /*
   * XMLHttpRequestPromise._getResponseText() -> Mixed
   *
   * Parses response text JSON if present.
   */
      XMLHttpRequestPromise.prototype._getResponseText = function () {
        var responseText;
        responseText = typeof this._xhr.responseText === 'string' ? this._xhr.responseText : '';
        switch (this._xhr.getResponseHeader('Content-Type')) {
        case 'application/json':
        case 'text/javascript':
          responseText = JSON.parse(responseText + '')
        }
        return responseText
      };
      /*
   * XMLHttpRequestPromise._getResponseUrl() -> String
   *
   * Actual response URL after following redirects.
   */
      XMLHttpRequestPromise.prototype._getResponseUrl = function () {
        if (this._xhr.responseURL != null) {
          return this._xhr.responseURL
        }
        if (/^X-Request-URL:/m.test(this._xhr.getAllResponseHeaders())) {
          return this._xhr.getResponseHeader('X-Request-URL')
        }
        return ''
      };
      /*
   * XMLHttpRequestPromise._handleError(reason, reject, status, statusText)
   * - reason (String)
   * - reject (Function)
   * - status (String)
   * - statusText (String)
   */
      XMLHttpRequestPromise.prototype._handleError = function (reason, reject, status, statusText) {
        this._detachWindowUnload();
        return reject({
          reason: reason,
          status: status || this._xhr.status,
          statusText: statusText || this._xhr.statusText,
          xhr: this._xhr
        })
      };
      /*
   * XMLHttpRequestPromise._handleWindowUnload()
   */
      XMLHttpRequestPromise.prototype._handleWindowUnload = function () {
        return this._xhr.abort()
      };
      return XMLHttpRequestPromise
    }()
  });
  // source: node_modules/parse-headers/parse-headers.js
  require.define('parse-headers/parse-headers', function (module, exports, __dirname, __filename, process) {
    var trim = require('trim'), forEach = require('for-each'), isArray = function (arg) {
        return Object.prototype.toString.call(arg) === '[object Array]'
      };
    module.exports = function (headers) {
      if (!headers)
        return {};
      var result = {};
      forEach(trim(headers).split('\n'), function (row) {
        var index = row.indexOf(':'), key = trim(row.slice(0, index)).toLowerCase(), value = trim(row.slice(index + 1));
        if (typeof result[key] === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [
            result[key],
            value
          ]
        }
      });
      return result
    }
  });
  // source: node_modules/trim/index.js
  require.define('trim', function (module, exports, __dirname, __filename, process) {
    exports = module.exports = trim;
    function trim(str) {
      return str.replace(/^\s*|\s*$/g, '')
    }
    exports.left = function (str) {
      return str.replace(/^\s*/, '')
    };
    exports.right = function (str) {
      return str.replace(/\s*$/, '')
    }
  });
  // source: node_modules/for-each/index.js
  require.define('for-each', function (module, exports, __dirname, __filename, process) {
    var isFunction = require('is-function');
    module.exports = forEach;
    var toString = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function forEach(list, iterator, context) {
      if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
      }
      if (arguments.length < 3) {
        context = this
      }
      if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context);
      else if (typeof list === 'string')
        forEachString(list, iterator, context);
      else
        forEachObject(list, iterator, context)
    }
    function forEachArray(array, iterator, context) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          iterator.call(context, array[i], i, array)
        }
      }
    }
    function forEachString(string, iterator, context) {
      for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
      }
    }
    function forEachObject(object, iterator, context) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          iterator.call(context, object[k], k, object)
        }
      }
    }
  });
  // source: node_modules/is-function/index.js
  require.define('is-function', function (module, exports, __dirname, __filename, process) {
    module.exports = isFunction;
    var toString = Object.prototype.toString;
    function isFunction(fn) {
      var string = toString.call(fn);
      return string === '[object Function]' || typeof fn === 'function' && string !== '[object RegExp]' || typeof window !== 'undefined' && (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt)
    }
    ;
  });
  // source: node_modules/object-assign/index.js
  require.define('object-assign', function (module, exports, __dirname, __filename, process) {
    /* eslint-disable no-unused-vars */
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === undefined) {
        throw new TypeError('Object.assign cannot be called with null or undefined')
      }
      return Object(val)
    }
    module.exports = Object.assign || function (target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key]
          }
        }
        if (Object.getOwnPropertySymbols) {
          symbols = Object.getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]]
            }
          }
        }
      }
      return to
    }
  });
  // source: src/router.coffee
  require.define('./router', function (module, exports, __dirname, __filename, process) {
    var module;
    module = require('./module');
    module.exports = {
      route: function (module, page) {
      }
    }
  });
  // source: src/index.coffee
  require.define('./index', function (module, exports, __dirname, __filename, process) {
    var Promise, exports, riot;
    Promise = require('broken/lib');
    riot = require('riot/riot');
    if (typeof window !== 'undefined' && window !== null) {
      window.riot = riot
    }
    exports = {
      module: require('./module'),
      router: require('./router')
    };
    if (typeof window !== 'undefined' && window !== null) {
      window.Daisho = exports
    }
    module.exports = exports
  });
  require('./index')
}.call(this, this))//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm9rZW4vbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3pvdXNhbi96b3VzYW4tbWluLmpzIiwibm9kZV9tb2R1bGVzL3Jpb3QvcmlvdC5qcyIsIm1vZHVsZS5jb2ZmZWUiLCJub2RlX21vZHVsZXMveGhyLXByb21pc2UtZXM2L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL3BhcnNlLWhlYWRlcnMuanMiLCJub2RlX21vZHVsZXMvdHJpbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mb3ItZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1mdW5jdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwicm91dGVyLmNvZmZlZSIsImluZGV4LmNvZmZlZSJdLCJuYW1lcyI6WyJQcm9taXNlIiwiUHJvbWlzZUluc3BlY3Rpb24iLCJyZXF1aXJlIiwic3VwcHJlc3NVbmNhdWdodFJlamVjdGlvbkVycm9yIiwiYXJnIiwic3RhdGUiLCJ2YWx1ZSIsInJlYXNvbiIsInByb3RvdHlwZSIsImlzRnVsZmlsbGVkIiwiaXNSZWplY3RlZCIsInJlZmxlY3QiLCJwcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInRoZW4iLCJlcnIiLCJzZXR0bGUiLCJwcm9taXNlcyIsImFsbCIsIm1hcCIsImNhbGxiYWNrIiwiY2IiLCJlcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0IiwiZSIsIm4iLCJ5IiwiY2FsbCIsImkiLCJwIiwibyIsInIiLCJjIiwidSIsInMiLCJmIiwibGVuZ3RoIiwic3BsaWNlIiwiTXV0YXRpb25PYnNlcnZlciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm9ic2VydmUiLCJhdHRyaWJ1dGVzIiwic2V0QXR0cmlidXRlIiwic2V0SW1tZWRpYXRlIiwic2V0VGltZW91dCIsInB1c2giLCJUeXBlRXJyb3IiLCJ2IiwiY29uc29sZSIsImxvZyIsInN0YWNrIiwibCIsImEiLCJ0aW1lb3V0IiwiRXJyb3IiLCJab3VzYW4iLCJzb29uIiwiZ2xvYmFsIiwid2luZG93IiwidW5kZWZpbmVkIiwicmlvdCIsInZlcnNpb24iLCJzZXR0aW5ncyIsIl9fdWlkIiwiX192aXJ0dWFsRG9tIiwiX190YWdJbXBsIiwiR0xPQkFMX01JWElOIiwiUklPVF9QUkVGSVgiLCJSSU9UX1RBRyIsIlJJT1RfVEFHX0lTIiwiVF9TVFJJTkciLCJUX09CSkVDVCIsIlRfVU5ERUYiLCJUX0JPT0wiLCJUX0ZVTkNUSU9OIiwiU1BFQ0lBTF9UQUdTX1JFR0VYIiwiUkVTRVJWRURfV09SRFNfQkxBQ0tMSVNUIiwiSUVfVkVSU0lPTiIsImRvY3VtZW50TW9kZSIsIm9ic2VydmFibGUiLCJlbCIsImNhbGxiYWNrcyIsInNsaWNlIiwiQXJyYXkiLCJvbkVhY2hFdmVudCIsImZuIiwicmVwbGFjZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJvbiIsImV2ZW50cyIsIm5hbWUiLCJwb3MiLCJ0eXBlZCIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsIm9mZiIsImFyciIsIm9uZSIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJpZ2dlciIsImFyZ2xlbiIsImFyZ3MiLCJmbnMiLCJidXN5IiwiY29uY2F0IiwiUkVfT1JJR0lOIiwiRVZFTlRfTElTVEVORVIiLCJSRU1PVkVfRVZFTlRfTElTVEVORVIiLCJBRERfRVZFTlRfTElTVEVORVIiLCJIQVNfQVRUUklCVVRFIiwiUkVQTEFDRSIsIlBPUFNUQVRFIiwiSEFTSENIQU5HRSIsIlRSSUdHRVIiLCJNQVhfRU1JVF9TVEFDS19MRVZFTCIsIndpbiIsImRvYyIsImhpc3QiLCJoaXN0b3J5IiwibG9jIiwibG9jYXRpb24iLCJwcm90IiwiUm91dGVyIiwiY2xpY2tFdmVudCIsIm9udG91Y2hzdGFydCIsInN0YXJ0ZWQiLCJjZW50cmFsIiwicm91dGVGb3VuZCIsImRlYm91bmNlZEVtaXQiLCJiYXNlIiwiY3VycmVudCIsInBhcnNlciIsInNlY29uZFBhcnNlciIsImVtaXRTdGFjayIsImVtaXRTdGFja0xldmVsIiwiREVGQVVMVF9QQVJTRVIiLCJwYXRoIiwic3BsaXQiLCJERUZBVUxUX1NFQ09ORF9QQVJTRVIiLCJmaWx0ZXIiLCJyZSIsIlJlZ0V4cCIsIm1hdGNoIiwiZGVib3VuY2UiLCJkZWxheSIsImNsZWFyVGltZW91dCIsInN0YXJ0IiwiYXV0b0V4ZWMiLCJlbWl0IiwiY2xpY2siLCIkIiwiYmluZCIsIm5vcm1hbGl6ZSIsImlzU3RyaW5nIiwic3RyIiwiZ2V0UGF0aEZyb21Sb290IiwiaHJlZiIsImdldFBhdGhGcm9tQmFzZSIsImZvcmNlIiwiaXNSb290Iiwic2hpZnQiLCJ3aGljaCIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJkZWZhdWx0UHJldmVudGVkIiwidGFyZ2V0Iiwibm9kZU5hbWUiLCJwYXJlbnROb2RlIiwiaW5kZXhPZiIsImdvIiwidGl0bGUiLCJwcmV2ZW50RGVmYXVsdCIsInNob3VsZFJlcGxhY2UiLCJyZXBsYWNlU3RhdGUiLCJwdXNoU3RhdGUiLCJtIiwiZmlyc3QiLCJzZWNvbmQiLCJ0aGlyZCIsInNvbWUiLCJhY3Rpb24iLCJtYWluUm91dGVyIiwicm91dGUiLCJjcmVhdGUiLCJuZXdTdWJSb3V0ZXIiLCJzdG9wIiwiZXhlYyIsImZuMiIsInF1ZXJ5IiwicSIsIl8iLCJrIiwicmVhZHlTdGF0ZSIsImJyYWNrZXRzIiwiVU5ERUYiLCJSRUdMT0IiLCJSX01MQ09NTVMiLCJSX1NUUklOR1MiLCJTX1FCTE9DS1MiLCJzb3VyY2UiLCJGSU5EQlJBQ0VTIiwiREVGQVVMVCIsIl9wYWlycyIsImNhY2hlZEJyYWNrZXRzIiwiX3JlZ2V4IiwiX2NhY2hlIiwiX3NldHRpbmdzIiwiX2xvb3BiYWNrIiwiX3Jld3JpdGUiLCJicCIsIl9jcmVhdGUiLCJwYWlyIiwidGVzdCIsIl9icmFja2V0cyIsInJlT3JJZHgiLCJ0bXBsIiwiX2JwIiwicGFydHMiLCJpc2V4cHIiLCJsYXN0SW5kZXgiLCJpbmRleCIsInNraXBCcmFjZXMiLCJ1bmVzY2FwZVN0ciIsImNoIiwiaXgiLCJyZWNjaCIsImhhc0V4cHIiLCJsb29wS2V5cyIsImV4cHIiLCJrZXkiLCJ2YWwiLCJ0cmltIiwiaGFzUmF3Iiwic3JjIiwiYXJyYXkiLCJfcmVzZXQiLCJfc2V0U2V0dGluZ3MiLCJiIiwiZGVmaW5lUHJvcGVydHkiLCJzZXQiLCJnZXQiLCJfdG1wbCIsImRhdGEiLCJfbG9nRXJyIiwiaGF2ZVJhdyIsImVycm9ySGFuZGxlciIsImN0eCIsInJpb3REYXRhIiwidGFnTmFtZSIsInJvb3QiLCJfcmlvdF9pZCIsIl9nZXRUbXBsIiwiRnVuY3Rpb24iLCJSRV9RQkxPQ0siLCJSRV9RQk1BUksiLCJxc3RyIiwiaiIsImxpc3QiLCJfcGFyc2VFeHByIiwiam9pbiIsIlJFX0JSRU5EIiwiQ1NfSURFTlQiLCJhc1RleHQiLCJkaXYiLCJjbnQiLCJqc2IiLCJyaWdodENvbnRleHQiLCJfd3JhcEV4cHIiLCJtbSIsImx2IiwiaXIiLCJKU19DT05URVhUIiwiSlNfVkFSTkFNRSIsIkpTX05PUFJPUFMiLCJ0YiIsIm12YXIiLCJwYXJzZSIsIm1rZG9tIiwiX21rZG9tIiwicmVIYXNZaWVsZCIsInJlWWllbGRBbGwiLCJyZVlpZWxkU3JjIiwicmVZaWVsZERlc3QiLCJyb290RWxzIiwidHIiLCJ0aCIsInRkIiwiY29sIiwidGJsVGFncyIsInRlbXBsIiwiaHRtbCIsInRvTG93ZXJDYXNlIiwibWtFbCIsInJlcGxhY2VZaWVsZCIsInNwZWNpYWxUYWdzIiwiaW5uZXJIVE1MIiwic3R1YiIsInNlbGVjdCIsInBhcmVudCIsImZpcnN0Q2hpbGQiLCJzZWxlY3RlZEluZGV4IiwidG5hbWUiLCJjaGlsZEVsZW1lbnRDb3VudCIsInJlZiIsInRleHQiLCJkZWYiLCJta2l0ZW0iLCJpdGVtIiwidW5tb3VudFJlZHVuZGFudCIsIml0ZW1zIiwidGFncyIsInVubW91bnQiLCJtb3ZlTmVzdGVkVGFncyIsImNoaWxkIiwia2V5cyIsImZvckVhY2giLCJ0YWciLCJpc0FycmF5IiwiZWFjaCIsIm1vdmVDaGlsZFRhZyIsImFkZFZpcnR1YWwiLCJfcm9vdCIsInNpYiIsIl92aXJ0cyIsIm5leHRTaWJsaW5nIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJtb3ZlVmlydHVhbCIsImxlbiIsIl9lYWNoIiwiZG9tIiwicmVtQXR0ciIsIm11c3RSZW9yZGVyIiwiZ2V0QXR0ciIsImdldFRhZ05hbWUiLCJpbXBsIiwib3V0ZXJIVE1MIiwidXNlUm9vdCIsImNyZWF0ZVRleHROb2RlIiwiZ2V0VGFnIiwiaXNPcHRpb24iLCJvbGRJdGVtcyIsImhhc0tleXMiLCJpc1ZpcnR1YWwiLCJyZW1vdmVDaGlsZCIsImZyYWciLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiaXRlbXNMZW5ndGgiLCJfbXVzdFJlb3JkZXIiLCJvbGRQb3MiLCJUYWciLCJpc0xvb3AiLCJoYXNJbXBsIiwiY2xvbmVOb2RlIiwibW91bnQiLCJ1cGRhdGUiLCJjaGlsZE5vZGVzIiwiX2l0ZW0iLCJzaSIsIm9wIiwib3B0aW9ucyIsInNlbGVjdGVkIiwiX19zZWxlY3RlZCIsInN0eWxlTWFuYWdlciIsIl9yaW90IiwiYWRkIiwiaW5qZWN0Iiwic3R5bGVOb2RlIiwibmV3Tm9kZSIsInNldEF0dHIiLCJ1c2VyTm9kZSIsImlkIiwicmVwbGFjZUNoaWxkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJjc3NUZXh0UHJvcCIsInN0eWxlU2hlZXQiLCJzdHlsZXNUb0luamVjdCIsImNzcyIsImNzc1RleHQiLCJwYXJzZU5hbWVkRWxlbWVudHMiLCJjaGlsZFRhZ3MiLCJmb3JjZVBhcnNpbmdOYW1lZCIsIndhbGsiLCJub2RlVHlwZSIsImluaXRDaGlsZFRhZyIsInNldE5hbWVkIiwicGFyc2VFeHByZXNzaW9ucyIsImV4cHJlc3Npb25zIiwiYWRkRXhwciIsImV4dHJhIiwiZXh0ZW5kIiwidHlwZSIsImF0dHIiLCJub2RlVmFsdWUiLCJib29sIiwiY29uZiIsInNlbGYiLCJvcHRzIiwiaW5oZXJpdCIsImNsZWFuVXBEYXRhIiwiaW1wbEF0dHIiLCJwcm9wc0luU3luY1dpdGhQYXJlbnQiLCJfdGFnIiwiaXNNb3VudGVkIiwidXBkYXRlT3B0cyIsInRvQ2FtZWwiLCJub3JtYWxpemVEYXRhIiwiaXNXcml0YWJsZSIsImluaGVyaXRGcm9tUGFyZW50IiwibXVzdFN5bmMiLCJjb250YWlucyIsImlzSW5oZXJpdGVkIiwiaXNPYmplY3QiLCJyQUYiLCJtaXgiLCJpbnN0YW5jZSIsIm1peGluIiwiaXNGdW5jdGlvbiIsImdldE93blByb3BlcnR5TmFtZXMiLCJpbml0IiwiZ2xvYmFsTWl4aW4iLCJ0b2dnbGUiLCJhdHRycyIsIndhbGtBdHRyaWJ1dGVzIiwiaXNJblN0dWIiLCJrZWVwUm9vdFRhZyIsInB0YWciLCJ0YWdJbmRleCIsImdldEltbWVkaWF0ZUN1c3RvbVBhcmVudFRhZyIsIm9uQ2hpbGRVcGRhdGUiLCJpc01vdW50IiwiZXZ0Iiwic2V0RXZlbnRIYW5kbGVyIiwiaGFuZGxlciIsIl9wYXJlbnQiLCJldmVudCIsImN1cnJlbnRUYXJnZXQiLCJzcmNFbGVtZW50IiwiY2hhckNvZGUiLCJrZXlDb2RlIiwicmV0dXJuVmFsdWUiLCJwcmV2ZW50VXBkYXRlIiwiaW5zZXJ0VG8iLCJub2RlIiwiYmVmb3JlIiwiYXR0ck5hbWUiLCJyZW1vdmUiLCJpblN0dWIiLCJzdHlsZSIsImRpc3BsYXkiLCJzdGFydHNXaXRoIiwiZWxzIiwicmVtb3ZlQXR0cmlidXRlIiwic3RyaW5nIiwidG9VcHBlckNhc2UiLCJnZXRBdHRyaWJ1dGUiLCJhZGRDaGlsZFRhZyIsImNhY2hlZFRhZyIsIm5ld1BvcyIsIm5hbWVkVGFnIiwib2JqIiwicHJvcHMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCIkJCIsInNlbGVjdG9yIiwicXVlcnlTZWxlY3RvckFsbCIsInF1ZXJ5U2VsZWN0b3IiLCJDaGlsZCIsImdldE5hbWVkS2V5IiwiaXNBcnIiLCJ3IiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibGFzdFRpbWUiLCJub3d0aW1lIiwiRGF0ZSIsIm5vdyIsIk1hdGgiLCJtYXgiLCJtb3VudFRvIiwiX2lubmVySFRNTCIsInV0aWwiLCJtaXhpbnMiLCJ0YWcyIiwiYWxsVGFncyIsImFkZFJpb3RUYWdzIiwic2VsZWN0QWxsVGFncyIsInB1c2hUYWdzIiwicmlvdFRhZyIsIm5vZGVMaXN0IiwiX2VsIiwiZGVmaW5lIiwiYW1kIiwiWGhyIiwidXJsRm9yIiwiZmlsZSIsIm1vZHVsZURlZmluaXRpb25zIiwibW9kdWxlc1JlcXVpcmVkIiwibW9kdWxlcyIsIm1vZHVsZXNVcmwiLCJ1cmwiLCJtZXRob2QiLCJzZW5kIiwiX3RoaXMiLCJyZXMiLCJyZXNwb25zZVRleHQiLCJsb2FkIiwiZGVmYXVsdE1vZHVsZSIsIm1vZHVsZVJlcXVpcmVkIiwidGltZW91dElkIiwid2FpdHMiLCJkZWZpbml0aW9uIiwianMiLCJfZ2V0TW9kdWxlIiwibW9kdWxlTmFtZSIsIlBhcnNlSGVhZGVycyIsIlhNTEh0dHBSZXF1ZXN0UHJvbWlzZSIsIm9iamVjdEFzc2lnbiIsIkRFRkFVTFRfQ09OVEVOVF9UWVBFIiwiZGVmYXVsdHMiLCJoZWFkZXJzIiwiYXN5bmMiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiY29uc3RydWN0b3IiLCJoZWFkZXIiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIl9oYW5kbGVFcnJvciIsIl94aHIiLCJvbmxvYWQiLCJfZGV0YWNoV2luZG93VW5sb2FkIiwiX2dldFJlc3BvbnNlVGV4dCIsIl9lcnJvciIsIl9nZXRSZXNwb25zZVVybCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJfZ2V0SGVhZGVycyIsIm9uZXJyb3IiLCJvbnRpbWVvdXQiLCJvbmFib3J0IiwiX2F0dGFjaFdpbmRvd1VubG9hZCIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwidG9TdHJpbmciLCJnZXRYSFIiLCJfdW5sb2FkSGFuZGxlciIsIl9oYW5kbGVXaW5kb3dVbmxvYWQiLCJhdHRhY2hFdmVudCIsImRldGFjaEV2ZW50IiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJKU09OIiwicmVzcG9uc2VVUkwiLCJhYm9ydCIsInJlc3VsdCIsInJvdyIsImxlZnQiLCJyaWdodCIsImhhc093blByb3BlcnR5IiwiaXRlcmF0b3IiLCJjb250ZXh0IiwiZm9yRWFjaEFycmF5IiwiZm9yRWFjaFN0cmluZyIsImZvckVhY2hPYmplY3QiLCJjaGFyQXQiLCJvYmplY3QiLCJhbGVydCIsImNvbmZpcm0iLCJwcm9tcHQiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsImFzc2lnbiIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwYWdlIiwicm91dGVyIiwiRGFpc2hvIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFDQTtBQUFBLFFBQUlBLE9BQUosRUFBYUMsaUJBQWIsQztJQUVBRCxPQUFBLEdBQVVFLE9BQUEsQ0FBUSxtQkFBUixDQUFWLEM7SUFFQUYsT0FBQSxDQUFRRyw4QkFBUixHQUF5QyxLQUF6QyxDO0lBRUFGLGlCQUFBLEdBQXFCLFlBQVc7QUFBQSxNQUM5QixTQUFTQSxpQkFBVCxDQUEyQkcsR0FBM0IsRUFBZ0M7QUFBQSxRQUM5QixLQUFLQyxLQUFMLEdBQWFELEdBQUEsQ0FBSUMsS0FBakIsRUFBd0IsS0FBS0MsS0FBTCxHQUFhRixHQUFBLENBQUlFLEtBQXpDLEVBQWdELEtBQUtDLE1BQUwsR0FBY0gsR0FBQSxDQUFJRyxNQURwQztBQUFBLE9BREY7QUFBQSxNQUs5Qk4saUJBQUEsQ0FBa0JPLFNBQWxCLENBQTRCQyxX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