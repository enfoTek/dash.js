// Generated by CoffeeScript 1.12.4
var Chart, Dynamic, Tween, d3, randomColor,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Dynamic = require('../dynamic');

Tween = require('tween.js');

d3 = require('d3sho');

randomColor = require('randomcolor');

module.exports = Chart = (function(superClass) {
  extend(Chart, superClass);

  function Chart() {
    return Chart.__super__.constructor.apply(this, arguments);
  }

  Chart.prototype.tag = 'daisho-graphics-chart';

  Chart.prototype.html = require('../../templates/graphics/chart');

  Chart.prototype.margin = {
    top: 40,
    right: 40,
    bottom: 50,
    left: 90
  };

  Chart.prototype.width = 0;

  Chart.prototype.height = 400;

  Chart.prototype.yMin = 10;

  Chart.prototype.interpolationTime = 3000;

  Chart.prototype.redrawTime = 300;

  Chart.prototype.svg = null;

  Chart.prototype.chart = null;

  Chart.prototype.xA = null;

  Chart.prototype.yA = null;

  Chart.prototype.xAxis = null;

  Chart.prototype.yAxis = null;

  Chart.prototype.lines = null;

  Chart.prototype.points = null;

  Chart.prototype.notes = null;

  Chart.prototype.legend = null;

  Chart.prototype.lineWidth = 3;

  Chart.prototype.pointRadius = 6;

  Chart.prototype.dataHash = '';

  Chart.prototype.colorSeed = 10;

  Chart.prototype.colors = [];

  Chart.prototype.refreshTiming = 'after';

  Chart.prototype.nextColor = function() {
    var x;
    x = Math.sin(this._colorSeed++) * 10000;
    return randomColor({
      seed: Math.floor((x - Math.floor(x)) * 1000)
    });
  };

  Chart.prototype.init = function() {
    Chart.__super__.init.apply(this, arguments);
    this.colors = [];
    return this.on('mount', (function(_this) {
      return function() {
        var chart, svg;
        _this.svg = svg = d3.select(_this.root).select('svg');
        _this.parseTime = d3.timeParse('%Y-%m-%dT%H:%M:%S%Z');
        _this.chart = chart = svg.append('g').attr('transform', 'translate(' + _this.margin.left + ',' + _this.margin.top + ')');
        _this.lines = _this.chart.append('g').classed('lines', true);
        _this.points = _this.chart.append('g').classed('points-group', true);
        _this.notes = _this.chart.append('g').classed('notes', true);
        _this.xAxis = chart.append('g').classed('axis', true).classed('x-axis', true);
        _this.xAxis.append('text');
        _this.yAxis = chart.append('g').classed('axis', true).classed('y-axis', true);
        _this.yAxis.append('text');
        _this.legend = svg.append("g").classed('legend', true).attr('transform', 'translate(50,30)');
        _this.xScale = d3.scaleTime();
        return _this.yScale = d3.scaleLinear();
      };
    })(this));
  };

  Chart.prototype._refresh = function() {
    var color, datum, fn, height, i, k, legendOrdinal, len1, line, lineFn, maxes, notes, ordinal, point, series, serieses, width, x, xScale, xs, xys, yScale, ys, ysBuf;
    width = this.width || $(this.root).parent().width();
    height = this.height;
    if (width <= 0 || height <= 0) {
      return;
    }
    this.svg.attr('width', width).attr('height', height);
    serieses = this.data.get();
    if (!serieses[0]) {
      return;
    }
    this._colorSeed = this.colorSeed;
    this.colors.length = 0;
    width -= this.margin.left + this.margin.right;
    height -= this.margin.top + this.margin.bottom;
    xs = [];
    ys = [];
    xScale = this.xScale;
    yScale = this.yScale;
    xScale.rangeRound([0, width]).ticks(d3.timeDay.every(1));
    yScale.rangeRound([height, 0]);
    for (i in serieses) {
      series = serieses[i];
      if (series.type === 'line' || series.type === 'bar') {
        xs = xs.concat(series.xs);
        ys = ys.concat(series.ys);
      }
    }
    ysBuf = ys.map(serieses[0].fmt.y);
    ysBuf.push(this.yMin);
    xScale.domain(d3.extent(xs.map(serieses[0].fmt.x), (function(_this) {
      return function(x) {
        return _this.parseTime(x);
      };
    })(this)));
    yScale.domain(d3.extent(ysBuf, function(y) {
      return y;
    }));
    if (this.xA && this.yA) {
      this.xAxis.transition().duration(this.redrawTime).call(this.xA.scale(xScale));
      this.yAxis.transition().duration(this.redrawTime).call(this.yA.scale(yScale));
    } else {
      this.xA = d3.axisBottom(xScale).tickFormat(serieses[0].axis.x.ticks);
      this.xAxis.call(this.xA).attr('transform', 'translate(0,' + height + ')').select('text').attr('fill', '#000').attr('x', width).attr('y', -12).attr('dy', '0.71em').attr('text-anchor', 'end').text(series.axis.x.name);
      this.yA = d3.axisLeft(yScale).tickFormat(serieses[0].axis.y.ticks);
      this.yAxis.call(this.yA).select('text').attr('fill', '#000').attr('transform', 'rotate(-90)').attr('y', 6).attr('dy', '0.71em').attr('text-anchor', 'end').text(series.axis.y.name);
    }
    this.lines.selectAll('*').attr('opacity', 1).transition().duration(this.redrawTime).attr('opacity', 0).attr('d', lineFn).remove();
    this.points.selectAll('*').attr('opacity', 1).transition().duration(this.redrawTime).attr('opacity', 0).remove();
    this.notes.selectAll('*').attr('opacity', 1).transition().duration(this.redrawTime).attr('opacity', 0).remove();
    notes = [];
    for (i in serieses) {
      series = serieses[i];
      if (series.xs.length === 0 || series.ys.length === 0) {
        continue;
      }
      if (series.type === 'line') {
        xys = series.xs.map(function(x, j) {
          return [x, series.ys[j]];
        });
        lineFn = d3.line().x((function(_this) {
          return function(d) {
            return xScale(_this.parseTime(series.fmt.x(d[0] || 0)));
          };
        })(this)).y(function(d) {
          return yScale(series.fmt.y(d[1] || 0));
        });
        line = this.lines.append('path').classed('line', true).classed('line-' + series.series, true);
        color = this.nextColor();
        this.colors.push(color);
        line.datum(xys).attr('fill', 'none').attr('stroke', color).attr('stroke-linejoin', 'round').attr('stroke-linecap', 'round').attr('stroke-width', this.lineWidth).attr('d', lineFn);
        point = this.points.append('g').classed('points', true).classed('points-' + series.series, true);
        (function(_this) {
          return (function(series, point, line, color) {
            var lineLength, tip;
            lineLength = line.node().getTotalLength();
            tip = d3.tip().attr('class', 'tip tip-' + series.series).offset([-10, 0]).html(function(d) {
              return "<div class='tip-group'>\n  <span class='tip-label'>" + series.axis.x.name + ":</span>\n  <span class='tip-value' style='color:" + color + "'>" + (series.tip.x(series.fmt.x(d[0] || 0))) + "</span>\n</div>\n<div class='tip-group'>\n  <span class='tip-label'>" + series.axis.y.name + ":</span>\n  <pre class='tip-value' style='color:" + color + "'>" + (series.tip.y(series.fmt.y(d[1] || 0))) + "</pre>\n</div>";
            });
            point.call(tip);
            return line.attr('stroke-dashoffset', lineLength).attr('stroke-dasharray', lineLength + ' ' + lineLength).transition().duration(_this.interpolationTime).attrTween('stroke-dashoffset', function(ds) {
              var j, len, lineInterpolator;
              j = 0;
              len = ds.length;
              lineInterpolator = d3.interpolate(lineLength, 0);
              return function(t) {
                var p;
                if (t >= j / len && ds[j]) {
                  p = point.append('circle').classed('point', true).classed('point-' + series.series, true).datum(ds[j]).attr('stroke', color).attr('stroke-width', 0).attr('stroke-opacity', 0).attr('fill', color).attr('cx', function(d) {
                    return xScale(_this.parseTime(series.fmt.x(d[0] || 0)));
                  }).attr('cy', function(d) {
                    return yScale(series.fmt.y(d[1] || 0));
                  }).on('mouseover', tip.show).on('mouseout', tip.hide);
                  p.transition().duration(_this.redrawTime).attrTween('r', function(d) {
                    return d3.interpolate(0, _this.pointRadius);
                  });
                  j++;
                }
                return lineInterpolator(t);
              };
            });
          });
        })(this)(series, point, line, color);
      }
    }
    notes = {};
    maxes = [];
    for (k = 0, len1 = serieses.length; k < len1; k++) {
      series = serieses[k];
      if (series.type === 'notes') {
        xs = series.xs;
        ys = series.ys;
        for (i in xs) {
          x = xs[i];
          if (notes[x]) {
            notes[x].push(ys[i]);
          } else {
            notes[x] = [ys[i]];
          }
        }
      } else {
        xs = series.xs;
        ys = series.ys;
        for (i in xs) {
          x = xs[i];
          if ((maxes[x] == null) || maxes[x] < ys[i]) {
            maxes[x] = ys[i];
          }
        }
      }
    }
    fn = (function(_this) {
      return function(ys) {
        var tip;
        tip = d3.tip().attr('class', 'tip tip-notes').offset([-10, 0]).html(function(d) {
          return "<div class='tip-group'>\n  <span class='tip-label'>" + serieses[0].axis.x.name + ":</span>\n  <span class='tip-value'>" + (serieses[0].tip.x(series.fmt.x(d[0] || 0))) + "</span>\n</div>\n<div class='tip-group'>\n  <span class='tip-label'>Notes:</span>\n  <pre class='tip-value'>" + (ys.join('\n')) + "</pre>\n</div>";
        });
        point = _this.notes.append('circle').classed('point', true).classed('point-notes', true);
        point.call(tip);
        point.datum(datum).attr('stroke', '#048ba8').attr('stroke-width', 0).attr('stroke-opacity', 0).attr('fill', '#048ba8').attr('cx', function(d) {
          return xScale(_this.parseTime(serieses[0].fmt.x(d[0] || 0)));
        }).attr('cy', function(d) {
          return yScale(serieses[0].fmt.y(d[1] || 0)) - 20;
        }).on('mouseover', tip.show).on('mouseout', tip.hide);
        return point.transition().duration(_this.redrawTime).attrTween('r', function(d) {
          return d3.interpolate(0, _this.pointRadius * 1.5);
        });
      };
    })(this);
    for (x in notes) {
      ys = notes[x];
      datum = [x, maxes[x]];
      fn(ys);
    }
    ordinal = d3.scaleOrdinal().domain(serieses.map(function(s) {
      return s.series;
    }).filter(function(s) {
      return !!s;
    })).range(this.colors);
    this.legend.attr('transform', 'translate(' + width + ',' + this.margin.top + ')');
    legendOrdinal = d3.legendColor().shape('path', d3.symbol().type(d3.symbolCircle).size(150)()).shapePadding(10).scale(ordinal);
    return this.legend.call(legendOrdinal);
  };

  return Chart;

})(Dynamic);

//# sourceMappingURL=chart.js.map
